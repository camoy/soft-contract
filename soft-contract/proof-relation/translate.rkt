#lang typed/racket/base

(provide (all-defined-out))

(require racket/match
         racket/set
         racket/string
         (except-in racket/list remove-duplicates)
         "../utils/main.rkt"
         "../ast/main.rkt"
         "../runtime/main.rkt")

(struct exn:scv:smt:unsupported exn () #:transparent)

(: base-datatypes : (‚Ñò Natural) ‚Üí (Listof Sexp))
(define (base-datatypes arities)
  (define st-defs : (Listof Sexp)
    (for/list ([n arities])
      (define St_k (format-symbol "St_~a" n))
      (define tag_k (format-symbol "tag_~a" n))
      (define fields : (Listof Sexp) (for/list ([i n]) `(,(format-symbol "field_~a_~a" n i) V)))
      `(,St_k (,tag_k Int) ,@fields)))
  
  `(;; Unitype
    (declare-datatypes ()
      ((V ; TODO
        Undefined
        Null
        (N [real Real] [imag Real])
        (B [unbox_B Bool])
        (O [op Int])
        (Sym [sym Int])
        (Str [str Int])
        (Clo [arity Int] [clo_id Int])
        (And/C [conj_l V] [conj_r V])
        (Or/C [disj_l V] [disj_r V])
        (Not/C [neg V])
        (St/C [unbox_st/c Int])
        (Arr [unbox_Arr Int])
        (ArrD [unbox_ArrD Int])
        (Vec [unbox_Vec Int])
        ;; structs with hard-coded arities
        ,@st-defs)))
    ;; Result
    (declare-datatypes ()
     ((A
       (Val (unbox_Val V))
       (Blm (blm_pos Int) (blm_src Int))
       None)))
    ))

(define base-predicates : (Listof Sexp)
  '(;; Primitive predicates
    (define-fun is_false ([x V]) Bool
      (= x (B false)))
    (define-fun is_truish ([x V]) Bool
      (not (is_false x)))
    (define-fun is_proc ([x V]) Bool
      (or (is-O x) (is-Clo x)))
    (define-fun has_arity ((x V) (n Int)) Bool
      ;; TODO primitives too
      (exists ((i Int)) (= x (Clo n i))))
    (define-fun is-R ([x V]) Bool
      (and (is-N x) (= 0 (imag x))))
    (define-fun is-Z ([x V]) Bool
      (and (is-R x) (is_int (real x))))
    ))

(define hack-for-is_int : (Listof Sexp)
  '{(assert (forall ([x Real] [y Real])
              (=> (and (is_int x) (is_int y)) (is_int (+ x y)))))
    (assert (forall ([x Real] [y Real])
              (=> (and (is_int x) (is_int y)) (is_int (- x y)))))
    (assert (forall ([x Real] [y Real])
              (=> (and (is_int x) (is_int y)) (is_int (* x y)))))
    })

(: SMT-base : (‚Ñò Natural) ‚Üí (Listof Sexp))
(define (SMT-base struct-arities)
  `(,@(base-datatypes struct-arities)
    ,@base-predicates))

;; SMT target language
(define-type Term Sexp)
(define-type Formula Sexp) ; Term of type Bool in SMT
(struct Entry ([free-vars : (‚Ñò Symbol)] [facts : (Listof Formula)] [expr : Term]) #:transparent)
(struct App ([ctx : -œÑ] [params : (Listof Var-Name)]) #:transparent)
(struct Res ([ok : (Listof Entry)] [er : (Listof Entry)]) #:transparent)
(Defn-Entry . ::= . -o App)
(define-type Memo-Table
  ;; Memo table maps each function application to a pair of formulas:
  ;; - When the application succeeds
  ;; - When the application goes wrong
  (HashTable App Res))

(: encode : -M -Œì -e ‚Üí (Values (Listof Sexp) Sexp))
;; Encode query `M Œì ‚ä¢ e : (‚úì|‚úó|?)`,
;; spanning from `Œì, e`, only translating neccessary entries in `M`
(define (encode M Œì e)
  (define-values (refs top-entry) (encode-e ‚àÖeq Œì e))
  (let loop ([fronts : (‚Ñò Defn-Entry) refs]
             [seen : (‚Ñò Defn-Entry) refs]
             [def-prims : (‚Ñò (Listof Sexp)) ‚àÖ]
             [def-funs : Memo-Table (hash)])
    (cond
      [(set-empty? fronts)
       (define st-arities
         (for/fold ([acc : (‚Ñò Natural) ‚àÖeq])
                   ([entry seen])
           (match entry
             [(or (-st-mk s) (-st-p s) (-st-ac s _) (-st-mut s _)) #:when s
              (set-add acc (-struct-info-arity s))]
             [(or 'list? 'list-ref 'map)
              (set-add acc 2)]
             [_ acc])))
       (emit st-arities def-prims def-funs top-entry)]
      [else
       (define-values (fronts* seen* def-prims* def-funs*)
         (for/fold ([fronts* : (‚Ñò Defn-Entry) ‚àÖ]
                    [seen* : (‚Ñò Defn-Entry) seen]
                    [def-prims* : (‚Ñò (Listof Sexp)) def-prims]
                    [def-funs* : Memo-Table def-funs])
                   ([front fronts])
           (define-values (def-prims** def-funs** refs+)
             (match front
               [(App œÑ xs)
                (define As (hash-ref M œÑ))
                (define-values (refs entries) (encode-œÑ œÑ xs As))
                (values def-prims* (hash-set def-funs* front entries) refs)]
               [(? -o? o)
                (values (set-add def-prims* (def-o o)) def-funs* ‚àÖ)]))
           
           (define-values (fronts** seen**)
             (for/fold ([fronts** : (‚Ñò Defn-Entry) fronts*]
                        [seen** : (‚Ñò Defn-Entry) seen*])
                       ([ref refs+] #:unless (‚àã seen** ref))
               (values (set-add fronts** ref)
                       (set-add seen** ref))))
           (values fronts** seen** def-prims** def-funs**)))
       (loop fronts* seen* def-prims* def-funs*)])))

(: encode-œÑ : -œÑ (Listof Var-Name) (‚Ñò -A) ‚Üí (Values (‚Ñò Defn-Entry) Res))
;; Translate memo-table entry `œÑ(xs) ‚Üí {A‚Ä¶}` to pair of formulas for when application
;; fails and passes
(define (encode-œÑ œÑ xs As)
  (define-set refs : Defn-Entry)
  (define t‚Çìs (map ‚¶Éx‚¶Ñ xs))
  (define f‚Çï (fun-name œÑ xs))
  (define t‚Çê‚Çö‚Çö (-tapp f‚Çï t‚Çìs))
  (define bound (list->set xs))
  
  ;; Accumulate pair of formulas describing conditions for succeeding and erroring
  (define-values (oks ers)
    (for/fold ([oks : (Listof Entry) '()]
               [ers : (Listof Entry) '()])
              ([A As])
      (match A
        [(-ŒìW Œì (-W _ s‚Çê))
         (define e‚Çí‚Çñ
           (cond
             [s‚Çê
              (define-values (refs+ entry) (encode-e bound Œì s‚Çê))
              (refs-union! refs+)
              (match-define (Entry free-vars facts t‚Çê‚Çô‚Çõ) entry)
              (Entry free-vars
                     (cons `(= ,t‚Çê‚Çö‚Çö (Val ,t‚Çê‚Çô‚Çõ))
                           facts)
                     t‚Çê‚Çô‚Çõ)]
             [else
              (define-values (refs+ entry) (encode-e bound Œì #|hack|# -ff))
              (refs-union! refs+)
              (match-define (Entry free-vars facts _) entry)
              (Entry free-vars facts #|hack|# '(B false))]))
         (values (cons e‚Çí‚Çñ oks) ers)]
        [(-ŒìE Œì (-blm l+ lo _ _))
         (define e‚Çë·µ£
           (let-values ([(refs+ entry) (encode-e bound Œì #|hack|# -ff)])
             (refs-union! refs+)
             (match-define (Entry free-vars facts _) entry)
             (Entry free-vars
                    (cons `(= ,t‚Çê‚Çö‚Çö (Blm ,(‚¶Él‚¶Ñ l+) ,(‚¶Él‚¶Ñ lo)))
                          facts)
                    #|hack|# `(B false))))
         (values oks (cons e‚Çë·µ£ ers))])))
  
  (values refs (Res oks ers)))

(: encode-e : (‚Ñò Var-Name) -Œì -e ‚Üí (Values (‚Ñò Defn-Entry) Entry))
;; Encode pathcondition `Œì` and expression `e`,
(define (encode-e bound Œì e)

  (define-set free-vars : Symbol #:eq? #t)
  (define asserts-eval : (Listof Formula) '())
  (define asserts-prop : (Listof Formula) '())
  (define-set refs : Defn-Entry)
  (match-define (-Œì œÜs _ Œ≥s) Œì)

  (define fresh-free! : (‚Üí Symbol)
    (let ([i : Natural 0])
      (Œª ()
        (define x (format-symbol "i.~a" i))
        (set! i (+ 1 i))
        (free-vars-add! x)
        x)))

  (define (assert-eval! [t : Term] [a : Term]) : Void
    (set! asserts-eval (cons `(= ,t ,a) asserts-eval)))

  (define (assert-prop! [œÜ : Formula]) : Void
    (set! asserts-prop (cons œÜ asserts-prop)))

  ;; Encode that `e‚Çï(e‚Çìs)` has succcessfully returned
  (define/memo (‚¶Éapp‚¶Ñ-ok! [œÑ : -œÑ] [e‚Çï : -e] [xs : (Listof Var-Name)] [e‚Çìs : (Listof -e)]) : Term
    (define t‚Çï (‚¶Ée‚¶Ñ! e‚Çï))
    (define t‚Çìs (map ‚¶Ée‚¶Ñ! e‚Çìs))
    (define f‚Çï (fun-name œÑ xs))
    (define x‚Çê (fresh-free!))
    (define arity (length xs))
    (refs-add! (App œÑ xs))
    (assert-prop! `(exists ([i Int]) (= ,t‚Çï (Clo ,arity i))))
    (define t‚Çê‚Çö‚Çö (-tapp f‚Çï t‚Çìs))
    (assert-eval! t‚Çê‚Çö‚Çö `(Val ,x‚Çê))
    x‚Çê)

  (: ‚¶Éapp‚¶Ñ-err! : -œÑ -e (Listof Var-Name) (Listof -e) Mon-Party Mon-Party ‚Üí Void)
  ;; Encode that `e‚Çï(e‚Çìs)` has succcessfully returned
  (define (‚¶Éapp‚¶Ñ-err! œÑ e‚Çï xs e‚Çìs l+ lo)
    (define t‚Çï (‚¶Ée‚¶Ñ! e‚Çï))
    (define t‚Çìs (map ‚¶Ée‚¶Ñ! e‚Çìs))
    (define f‚Çï (fun-name œÑ xs))
    (define arity (length xs))
    (refs-add! (App œÑ xs))
    (assert-eval! (-tapp f‚Çï t‚Çìs) `(Blm ,(‚¶Él‚¶Ñ l+) ,(‚¶Él‚¶Ñ lo))))

  ;; encode the fact that `e` has successfully evaluated
  (define/memo (‚¶Ée‚¶Ñ! [e : -e]) : Term
    ;(printf "‚¶Ée‚¶Ñ!: ~a~n" (show-e e))
    (match e
      [(-b b) (‚¶Éb‚¶Ñ b)]
      [(? -ùíæ? ùíæ)
       (define t (‚¶Éùíæ‚¶Ñ ùíæ))
       (free-vars-add! t)
       t]
      [(? -o? o) `(O ,(‚¶Éo‚¶Ñ·µ• o))]
      [(-x x)
       (define t (‚¶Éx‚¶Ñ x))
       (cond [(‚àã bound x) t]
             [else (free-vars-add! t) t])]
      [(-Œª (? list? xs) e)
       (define n (length xs))
       (define t (fresh-free!))
       (assert-prop! `(is_proc ,t))
       (assert-prop! `(= (arity ,t) ,(length xs)))
       t]
      
      ;; Hacks for special applications go here
      [(-@ (-@ 'and/c ps _) es _)
       (define ts : (Listof Term) (for/list ([p ps]) (‚¶Ée‚¶Ñ! (-@ p es 0))))
       (define œÜ (-tand (for/list ([t ts]) `(is_truish ,t))))
       `(B ,œÜ)]
      [(-@ (-@ 'or/c ps _) es _)
       (define ts : (Listof Term) (for/list ([p ps]) (‚¶Ée‚¶Ñ! (-@ p es 0))))
       (define œÜ (-tor (for/list ([t ts]) `(is_truish ,t))))
       `(B ,œÜ)]
      [(-@ (-@ 'not/c (list p) _) es _)
       `(B (is_false ,(‚¶Ée‚¶Ñ! (-@ p es 0))))]
      [(-@ (-struct/c s cs _) es _)
       (define t‚Çö (‚¶Ée‚¶Ñ! (-@ (-st-p s) es 0)))
       (define ts : (Listof Term)
         (for/list ([(c i) (in-indexed cs)])
           (define e·µ¢ (-@ (-st-ac s (assert i exact-nonnegative-integer?)) es 0))
           (‚¶Ée‚¶Ñ! (-@ c (list e·µ¢) 0))))
       (define œÜ (-tand (for/list ([t (cons t‚Çö ts)]) `(is_truish ,t))))
       `(B ,œÜ)]
      [(-@ 'list es _)
       (define ts (map ‚¶Ée‚¶Ñ! es))
       (foldr
        (Œª ([t‚Çó : Term] [t·µ£ : Term])
          (refs-add! -cons)
          (define t‚Çö (fresh-free!))
          (assert-eval! (-tapp (‚¶Éo‚¶Ñ -cons) (list t‚Çó t·µ£)) `(Val ,t‚Çö))
          t‚Çö)
        'Null
        ts)]
      ;; End of hacks for special applications
      
      [(-@ (? -o? o) es _)
       (define ts (map ‚¶Ée‚¶Ñ! es))
       (refs-add! o)
       (cond
         [(o->pred o) => (Œª ([f : ((Listof Term) ‚Üí Term)]) (f ts))]
         [else
          (define x‚Çê (fresh-free!))
          (assert-eval! (-tapp (‚¶Éo‚¶Ñ o) ts) `(Val ,x‚Çê))
          x‚Çê])]
      
      [(-@ e‚Çï e‚Çìs _)
       (or
        (for/or : (Option Term) ([Œ≥ Œ≥s])
          (match-define (-Œ≥ œÑ bnd blm) Œ≥)
          (match-define (-binding œÜ‚Çï xs x->œÜ) bnd)
          (cond [(equal? e (binding->s bnd))
                 (‚¶Éapp‚¶Ñ-ok! œÑ e‚Çï xs e‚Çìs)]
                [else #f]))
        (begin
          #;(printf "Can't find tail for ~a among ~a~n"
                  (show-e e)
                  (for/list : (Listof Sexp) ([Œ≥ Œ≥s])
                    (match-define (-Œ≥ _ bnd _) Œ≥)
                    (show-s (binding->s bnd))))
          (fresh-free!)))]
      [(? -->?)
       (define t (fresh-free!))
       (assert-prop! `(is-Arr ,t))
       t]
      [(? -->i?)
       (define t (fresh-free!))
       (assert-prop! `(is-ArrD ,t))
       t]
      [(? -struct/c?)
       (define t (fresh-free!))
       (assert-prop! `(is-St/C ,t))
       t]
      [_ (error '‚¶Ée‚¶Ñ! "unhandled: ~a" (show-e e))]))

  (: ‚¶ÉŒ≥‚¶Ñ! : -Œ≥ ‚Üí Void)
  (define (‚¶ÉŒ≥‚¶Ñ! Œ≥)
    (match-define (-Œ≥ œÑ bnd blm) Œ≥)
    (define e‚Çê‚Çö‚Çö (binding->s bnd))
    (when e‚Çê‚Çö‚Çö
      (match-define (-binding _ xs _) bnd)
      (match-define (-@ e‚Çï e‚Çìs _) e‚Çê‚Çö‚Çö)
      (match blm
        [(cons l+ lo) (‚¶Éapp‚¶Ñ-err! œÑ e‚Çï xs e‚Çìs l+ lo)]
        [_      (void (‚¶Éapp‚¶Ñ-ok! œÑ e‚Çï xs e‚Çìs))])))

  (for ([Œ≥ (reverse Œ≥s)]) (‚¶ÉŒ≥‚¶Ñ! Œ≥))
  (for ([œÜ œÜs])
    (assert-prop! (tsimp (‚¶Ée‚¶Ñ! (œÜ->e œÜ)))))
  (define t‚Çú‚Çí‚Çö (‚¶Ée‚¶Ñ! e))

  (values refs (Entry free-vars `(,@(reverse asserts-eval) ,@(reverse asserts-prop)) t‚Çú‚Çí‚Çö)))

(: emit : (‚Ñò Natural) (‚Ñò (Listof Sexp)) Memo-Table Entry ‚Üí (Values (Listof Sexp) Sexp))
;; Emit base and target to prove/refute
(define (emit struct-arities def-prims def-funs top)
  (match-define (Entry consts facts goal) top)

  (define emit-hack-for-is_int : (Listof Sexp)
    (cond [(should-include-hack-for-is_int? facts) hack-for-is_int]
          [else '()]))
  
  (define emit-def-prims
    (for/fold ([acc : (Listof Sexp) '()])
              ([def-prim def-prims])
      (append def-prim acc)))
  
  (define-values (emit-dec-funs emit-def-funs)
    (for/fold ([decs : (Listof Sexp) '()]
               [defs : (Listof Sexp) '()])
              ([(f-xs res) def-funs])
      (match-define (App œÑ xs) f-xs)
      (define n (length xs))
      (define t‚Çìs (map ‚¶Éx‚¶Ñ xs))
      (define f‚Çï (fun-name œÑ xs))
      (define t‚Çê‚Çö‚Çö (-tapp f‚Çï t‚Çìs))
      (match-define (Res oks ers) res)

      (: mk-cond : (Listof Entry) ‚Üí (Listof Sexp))
      (define (mk-cond entries)
        (for/list ([entry entries])
          (match-define (Entry xs facts _) entry)
          (define conj (-tand facts))
          (cond
            [(set-empty? xs)
             conj]
            [else
             (define exists-xs : (Listof Sexp) (for/list ([x xs]) `(,x V)))
             `(exists ,exists-xs ,conj)])))

      (define ok-conds (mk-cond oks))
      (define er-conds (mk-cond ers))
      (define params : (Listof Sexp) (for/list ([x t‚Çìs]) `(,x V)))

      (: assrt : (Listof Sexp) Sexp ‚Üí Sexp)
      (define (assrt params cnd)
        `(assert
          ,(cond
             [(null? params) cnd]
             [else `(forall ,params (! ,cnd :pattern ,t‚Çê‚Çö‚Çö))])))
      
      (values
       (cons `(declare-fun ,f‚Çï ,(make-list n 'V) A) decs)
       (list*
        ;; For each function, generate implications from returns and blames
        (assrt params `(=> (is-Val ,t‚Çê‚Çö‚Çö) ,(-tor ok-conds)))
        (assrt params `(=> (is-Blm ,t‚Çê‚Çö‚Çö) ,(-tor er-conds)))
        defs))))

  (define emit-dec-consts : (Listof Sexp) (for/list ([x consts]) `(declare-const ,x V)))
  (define emit-asserts : (Listof Sexp) (for/list ([œÜ facts]) `(assert ,œÜ)))

  (values `(,@(SMT-base struct-arities)
            ,@emit-def-prims
            ,@emit-hack-for-is_int
            ,@emit-dec-funs
            ,@emit-def-funs
            ,@emit-dec-consts
            ,@emit-asserts)
          goal))

(: ‚¶Él‚¶Ñ : Mon-Party ‚Üí Natural)
(define ‚¶Él‚¶Ñ
  (let-values ([(l->nat _‚ÇÅ _‚ÇÇ) ((inst unique-nat Mon-Party))])
    l->nat))

(: ‚¶Éstruct-info‚¶Ñ : -struct-info ‚Üí Natural)
(define ‚¶Éstruct-info‚¶Ñ
  (let-values ([(si->nat _‚ÇÅ _‚ÇÇ) ((inst unique-nat -struct-info))])
    si->nat))

(: ‚¶Éb‚¶Ñ : Base ‚Üí Term)
(define (‚¶Éb‚¶Ñ b)
  (match b
    [#f `(B false)]
    [#t `(B true)]
    [(? number? x) `(N ,(real-part x) ,(imag-part x))]
    [(? symbol? s) `(Sym ,(‚¶Ésym‚¶Ñ s))]
    [(? string? s) `(Str ,(‚¶Éstr‚¶Ñ s))]
    [(list) `Null]
    [_ (error '‚¶Ée‚¶Ñ! "base value: ~a" b)]))

(: ‚¶Éùíæ‚¶Ñ : -ùíæ ‚Üí Symbol)
(define (‚¶Éùíæ‚¶Ñ ùíæ) (format-symbol "t.~a" (-ùíæ-name ùíæ)))

(: ‚¶Éx‚¶Ñ : Var-Name ‚Üí Symbol)
(define (‚¶Éx‚¶Ñ x)
  
  (: elim-sub/sup-scripts : String ‚Üí String)
  (define (elim-sub/sup-scripts s)

    (: subst : Char ‚Üí (Listof Char))
    (define (subst c)
      (case c
        [(#\‚ÇÄ) '(#\_ #\_ #\0)]
        [(#\‚ÇÅ) '(#\_ #\_ #\1)]
        [(#\‚ÇÇ) '(#\_ #\_ #\2)]
        [(#\‚ÇÉ) '(#\_ #\_ #\3)]
        [(#\‚ÇÑ) '(#\_ #\_ #\4)]
        [(#\‚ÇÖ) '(#\_ #\_ #\5)]
        [(#\‚ÇÜ) '(#\_ #\_ #\6)]
        [(#\‚Çá) '(#\_ #\_ #\7)]
        [(#\‚Çà) '(#\_ #\_ #\8)]
        [(#\‚Çâ) '(#\_ #\_ #\9)]
        [(#\‚Å∞) '(#\_ #\^ #\0)]
        [(#\¬π) '(#\_ #\^ #\1)]
        [(#\¬≤) '(#\_ #\^ #\2)]
        [(#\¬≥) '(#\_ #\^ #\3)]
        [(#\‚Å¥) '(#\_ #\^ #\4)]
        [(#\‚Åµ) '(#\_ #\^ #\5)]
        [(#\‚Å∂) '(#\_ #\^ #\6)]
        [(#\‚Å∑) '(#\_ #\^ #\7)]
        [(#\‚Å∏) '(#\_ #\^ #\8)]
        [(#\‚Åπ) '(#\_ #\^ #\9)]
        [else (list c)]))

    (list->string (append-map subst (string->list s))))

  (cond [(integer? x) (format-symbol "x.~a" x)]
        [else (string->symbol (elim-sub/sup-scripts (symbol->string x)))]))

(: fun-name : -œÑ (Listof Var-Name) ‚Üí Symbol)
(define fun-name
  (let ([m : (HashTable (Pairof (Listof Var-Name) -œÑ) Symbol) (make-hash)])
    (Œª (œÑ xs)
      (hash-ref! m (cons xs œÑ) (Œª () (format-symbol "f.~a" (hash-count m)))))))

(: ‚¶Éo‚¶Ñ : -o ‚Üí Symbol)
(define (‚¶Éo‚¶Ñ o)
  (match o
    [(-st-p s) (st-p-name s)]
    [(-st-mk s) (st-mk-name s)]
    [(-st-ac s i) (st-ac-name s i)]
    [(-st-mut s _) (error '‚¶Éo‚¶Ñ "TODO: mutator for ~a" (st-name s))]
    [(? symbol? o) (format-symbol "o.~a" o)]))

(: ‚¶Éo‚¶Ñ·µ• : -o ‚Üí Integer)
(define ‚¶Éo‚¶Ñ·µ•
  (let ([m : (HashTable -o Integer) (make-hash)])
    (Œª (o) (hash-ref! m o (Œª () (hash-count m))))))

(define ‚¶Ésym‚¶Ñ : (Symbol ‚Üí Integer)
  (let ([m : (HashTable Symbol Integer) (make-hasheq)])
    (Œª (s) (hash-ref! m s (Œª () (hash-count m))))))

(define ‚¶Éstr‚¶Ñ : (String ‚Üí Integer)
  (let ([m : (HashTable String Integer) (make-hash)])
    (Œª (s) (hash-ref! m s (Œª () (hash-count m))))))

(: o->pred : -o ‚Üí (Option ((Listof Term) ‚Üí Term)))
(define (o->pred o)
  (case o
    [(defined?)
     (Œª ([ts : (Listof Term)])
       `(B (not (is-Undefined ,@ts))))]
    [(number?)
     (Œª ([ts : (Listof Term)])
       `(B (is-N ,@ts)))]
    [(real?)
     (Œª ([ts : (Listof Term)])
       `(B (is-R ,@ts)))]
    [(integer?)
     (Œª ([ts : (Listof Term)])
       `(B (is-Z ,@ts)))]
    [(symbol?)
     (Œª ([ts : (Listof Term)])
       `(B (is-Sym ,@ts)))]
    [(string?)
     (Œª ([ts : (Listof Term)])
       `(B (is-Str ,@ts)))]
    [(procedure?)
     (Œª ([ts : (Listof Term)])
       `(B (is_proc ,@ts)))]
    [(boolean?)
     (Œª ([ts : (Listof Term)])
       `(B (is-B ,@ts)))]
    [(vector?)
     (Œª ([ts : (Listof Term)])
       `(B (is-Vec ,@ts)))]
    [(equal?)
     (Œª ([ts : (Listof Term)])
       `(B (= ,@ts)))]
    [(not false?)
     (Œª ([ts : (Listof Term)])
       (match ts
         [(list `(B (is_false ,t))) `(B (is_truish ,t))]
         [(list `(B (is_truish ,t))) `(B (is_false ,t))]
         [ts `(B (is_false ,@ts))]))]
    [else
     (match o
       [(-st-p s)
        (match-define (-struct-info ùíæ n _) s)
        (define p (format-symbol "is-St_~a" n))
        (define tag (format-symbol "tag_~a" n))
        (Œª ([ts : (Listof Term)])
          `(B (and (,p ,@ts) (= (,tag ,@ts) ,(‚¶Éstruct-info‚¶Ñ s)))))]
       [_ #f])]))

(: def-o : -o ‚Üí (Listof Sexp))
(define (def-o o)
  (case o
    [(defined?)
     '{(define-fun o.defined? ([x V]) A
         (Val (B (not (= x Undefined)))))}]
    [(not false?)
     '{(define-fun o.not ([x V]) A
         (Val (B (= x (B false)))))}]
    [(boolean?)
     '{(define-fun o.boolean? ([x V]) A
         (Val (B (is-B x))))}]
    [(vector?)
     '{(define-fun o.vector? ([x V]) A
         (Val (B (is-Vec x))))}]
    [(add1)
     '{(define-fun o.add1 ([x V]) A
         (if (is-N x)
             (Val (N (+ 1 (real x)) (imag x)))
             None))}]
    [(sub1)
     '{(define-fun o.sub1 ([x V]) A
         (if (is-N x)
             (Val (N (- (real x) 1) (imag x)))
             None))}]
    [(+)
     '{(define-fun o.+ ([x V] [y V]) A
         (if (and (is-N x) (is-N y))
             (Val (N (+ (real x) (real y))
                     (+ (imag x) (imag y))))
             None))}]
    [(-)
     '{(define-fun o.- ([x V] [y V]) A
         (if (and (is-N x) (is-N y))
             (Val (N (- (real x) (real y))
                     (- (imag x) (imag y))))
             None))}]
    [(*)
     '{(define-fun o.* ([x V] [y V]) A
         (if (and (is-N x) (is-N y))
             (Val (N (- (* (real x) (real y))
                        (* (imag x) (imag y)))
                     (+ (* (real x) (imag y))
                        (* (imag x) (real y)))))
             None))}]
    [(/)
     '{(define-fun o./ ([x V] [y V]) A
         (if (and (is-N x) (is-N y))
             (let ((a (real x))
                   (b (imag x))
                   (c (real y))
                   (d (imag y)))
               (let ((ccdd (+ (* c c) (* d d))))
                 (if (= ccdd 0)
                   None
                   (Val (N (/ (+ (* a c) (* b d)) ccdd)
                           (/ (- (* b c) (* a d)) ccdd))))))
             None))}]
    [(=)
     '{(define-fun o.= ([x V] [y V]) A
         (if (and (is-N x) (is-N y))
             (Val (B (= x y)))
             None))}]
    [(> < >= <=) (lift-‚Ñù¬≤-ùîπ (assert o symbol?))]
    [(equal?)
     '{(define-fun o.equal? ([x V] [y V]) A
         (Val (B (= x y))))}]
    [(integer?)
     '{(define-fun o.integer? ([x V]) A (Val (B (is-Z x))))}]
    [(real?)
     '{(define-fun o.real? ([x V]) A (Val (B (is-R x))))}]
    [(number?) ; TODO
     '{(define-fun o.number? ([x V]) A (Val (B (is-N x))))}]
    [(symbol?)
     '{(define-fun o.symbol? ([x V]) A (Val (B (is-Sym x))))}]
    [(string?)
     '{(define-fun o.string? ([x V]) A (Val (B (is-Str x))))}]
    [(null? empty?)
     '{(define-fun o.null? ([x V]) A
         (Val (B (= x Null))))}]
    [(procedure?)
     '{(define-fun o.procedure? ([x V]) A
         (Val (B (is_proc x))))}]
    [(list?)
     `{(declare-fun is_list (V) Bool)
       (assert (is_list Null))
       (assert (forall ([h V] [t V])
                       (=> (is_list t)
                           (is_list (St_2 ,(‚¶Éstruct-info‚¶Ñ -s-cons) h t)))))
       (define-fun o.list? ([x V]) A
         (Val (B (is_list x))))}]
    [(map)
     `{(declare-fun o.map (V V) A)
       (assert (forall ([f V]) (= (o.map f Null) (Val Null))))
       (assert (forall ([f V] [h V] [t V] [a V] [fa V])
                       (=> (= (o.map f t) (Val fa)) ; FIXME: need (f h) to terminate
                           (exists ([b V])
                                   (= (o.map f (St_2 ,(‚¶Éstruct-info‚¶Ñ -s-cons) h t))
                                      (Val (St_2 ,(‚¶Éstruct-info‚¶Ñ -s-cons) b fa)))))))}]
    [(append)
     `{(declare-fun o.append (V V) A)
       (assert (forall ([r V]) (= (o.append Null r) (Val r))))
       (assert (forall ([h V] [t V] [r V] [tr V])
                       (=> (= (o.append t r) (Val tr))
                           (= (o.append (St_2 ,(‚¶Éstruct-info‚¶Ñ -s-cons) h t) r)
                              (Val (St_2 ,(‚¶Éstruct-info‚¶Ñ -s-cons) h tr))))))}]
    [(arity-includes?)
     '{(define-fun o.arity-includes? ([a V] [i V]) A
         (if (and (#|TODO|# is-Z a) (is-Z i))
             (Val (B (= a i)))
             None))}]
    [(procedure-arity)
     '{(define-fun o.procedure-arity ([x V]) A
         (if (is_proc x)
             (Val (N (arity x) 0))
             None))}]
    [(string-length)
     '{(declare-fun o.string-length (V) A)
       (assert (forall ([x V])
                       (! (iff (is-Str x)
                               (exists ([n Int])
                                       (and (= (o.string-length x) (Val (N n 0)))
                                            (>= n 0))))
                          :pattern (o.string-length x))))
       (assert (forall ([x V])
                       (! (iff (not (is-Str x)) (= (o.string-length x) None))
                          :pattern (o.string-length x))))}]
    [(and/c)
     '{(define-fun o.and/c ([l V] [r V]) A (Val (And/C l r)))}]
    [(or/c)
     '{(define-fun o.or/c ([l V] [r V]) A (Val (Or/C l r)))}]
    [(not/c)
     '{(define-fun o.not/c ([c V]) A (Val (Not/C c)))}]
    [(exact?)
     '{(declare-fun o.exact? (V) A)
       (assert (forall ([x V]) (exists ([b Bool]) (= (o.exact? x) (Val (B b))))))}]
    [(inexact?)
     '{(declare-fun o.inexact? (V) A)
       (assert (forall ([x V]) (exists ([b Bool]) (= (o.inexact? x) (Val (B b))))))}]
    [(vector-length)
     '{(declare-fun o.vector-length (V) A)
       (assert (forall ([x V])
                 (= (is-Vec x)
                    (exists ([n Int])
                            (and (>= n 0)
                                 (= (o.vector-length x) (Val (N n 0))))))))
       (assert (forall ([x V]) (= (not (is-Vec x)) (= (o.vector-length x) None))))}]
    [(vector-ref)
     '{(declare-fun o.vector-ref (V V) A)
       (assert (forall ([v V] [i V])
                 (= (and (is-Vec v) (is-Z i)) ; TODO bound
                    (exists ([a V]) (= (o.vector-ref v i) (Val a))))))
       (assert (forall ([v V] [i V])
                 (= (not (and (is-Vec v) (is-Z i))) ; TODO bound
                    (= (o.vector-ref v i) None))))}]
    [else
     (match o
       [(-st-p s)
        (match-define (-struct-info _ n _) s)
        (define is-St (format-symbol "is-St_~a" n))
        (define tag (format-symbol "tag_~a" n))
        `{(define-fun ,(st-p-name s) ((x V)) A
            (Val (B (and (,is-St x) (= (,tag x) ,(‚¶Éstruct-info‚¶Ñ s))))))}]
       [(-st-mk s)
        (match-define (-struct-info _ n _) s)
        (define-values (decs xs)
          (for/lists ([decs : (Listof Sexp)] [xs : (Listof Symbol)])
                     ([i n])
            (define x (format-symbol "x~a" i))
            (values `(,x V) x)))
        (define St (format-symbol "St_~a" n))
        `{(define-fun ,(st-mk-name s) ,decs A
            (Val (,St ,(‚¶Éstruct-info‚¶Ñ s) ,@xs)))}]
       [(-st-ac s i)
        (match-define (-struct-info _ n _) s)
        (define is-St (format-symbol "is-St_~a" n))
        (define field (format-symbol "field_~a_~a" n i))
        (define tag (format-symbol "tag_~a" n))
        `{(define-fun ,(st-ac-name s i) ((x V)) A
            (if (and (,is-St x) (= (,tag x) ,(‚¶Éstruct-info‚¶Ñ s)))
                (Val (,field x))
                None))}]
       [(-st-mut s _)
        (error 'def-o "mutator for ~a" (st-name s))]
       [_
        (raise (exn:scv:smt:unsupported (format "Unsupported: ~a" o) (current-continuation-marks)))])]))

(: lift-‚Ñù¬≤-ùîπ : Symbol ‚Üí (Listof Sexp))
(define (lift-‚Ñù¬≤-ùîπ o)
  (define name (‚¶Éo‚¶Ñ o))
  `{(define-fun ,name ([x V] [y V]) A
      (if (and (is-R x) (is-R y))
          (Val (B (,o (real x) (real y))))
          None))})

(: next-int! : ‚Üí Natural)
(define next-int!
  (let ([i : Natural 0])
    (Œª ()
      (begin0 i (set! i (+ 1 i))))))

(: should-include-hack-for-is_int? : (Listof Sexp) ‚Üí Boolean)
(define (should-include-hack-for-is_int? œÜs)
  (and (has-op? œÜs 'o.integer?)
       (for/or : Boolean ([o (in-list '(o.+ o.- o.*))])
         (has-op? œÜs o))))

(: has-op? : (Listof Sexp) Symbol ‚Üí Boolean)
(define (has-op? œÜs o)

  (define go : (Sexp ‚Üí Boolean)
    (match-lambda
      [(cons h t) (or (go h) (go t))]
      [s (equal? s o)]))

  (ormap go œÜs))

(:* -tand -tor : (Listof Term) ‚Üí Term)
(define -tand
  (match-lambda
    ['() 'true]
    [(list x) x]
    [xs `(and ,@xs)]))
(define -tor
  (match-lambda
    ['() 'false]
    [(list x) x]
    [xs `(or ,@xs)]))

(: -tapp : Term (Listof Term) ‚Üí Term)
(define (-tapp f xs) (if (null? xs) f `(,f ,@xs)))

(: tsimp : Term ‚Üí Sexp)
(define (tsimp t)
  (match t
    [`(B (is_false (B ,œÜ))) `(not ,œÜ)]
    [`(B (is_truish (B ,œÜ))) œÜ]
    [`(B ,œÜ) œÜ]
    [_ `(is_truish ,t)]))

(define (st-name [s : -struct-info]) : Symbol (-ùíæ-name (-struct-info-id s)))
(define (st-p-name [s : -struct-info]) : Symbol (format-symbol "st.~a?" (st-name s)))
(define (st-mk-name [s : -struct-info]) : Symbol (format-symbol "st.~a" (st-name s)))
(define (st-ac-name [s : -struct-info] [i : Natural]) : Symbol (format-symbol "st.~a_~a" (st-name s) i))

(module+ test
  (require typed/rackunit)
  
  (define +x (-x 'x))
  (define +y (-x 'y))
  (define +z (-x 'z))
  (encode ‚ä•M
           (Œì+ ‚ä§Œì
                (-@ 'integer? (list +x) 0)
                (-@ 'integer? (list +y) 0)
                (-@ '= (list +z (-@ '+ (list +x +y) 0)) 0))
           (-@ 'integer? (list +z) 0)))
