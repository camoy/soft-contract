#lang typed/racket/base

(provide widening@)

(require (for-syntax racket/base
                     racket/list
                     racket/syntax
                     syntax/parse)
         racket/match
         racket/list
         racket/set
         racket/bool
         typed/racket/unit
         set-extras
         "../utils/main.rkt"
         "../ast/signatures.rkt"
         "../runtime/signatures.rkt"
         "../signatures.rkt"
         "signatures.rkt")

(define-unit widening@
  (import static-info^ local-prover^ pc^ sto^ pretty-print^ env^ val^ summ^)
  (export widening^)

  (: Œì+ : -Œì -?t * ‚Üí -Œì)
  ;; Strengthen path condition `Œì` with `s`
  (define (Œì+ Œì . ts)

    (: œÜs+ : -Œì -t ‚Üí -Œì)
    (define (œÜs+ œÜs œÜ)      
      
      (: iter : -Œì -t ‚Üí (U -Œì (Pairof -Œì -Œì)))
      (define (iter œÜs œÜ)
        (match (for/or : (Option (List -Œì -t -t)) ([œÜ·µ¢ œÜs])
                 (cond [(œÜ+ œÜ·µ¢ œÜ) => (Œª ([œÜs* : -Œì]) (list œÜs* œÜ·µ¢ œÜ))]
                       [else #f]))
          [(list œÜs* œÜ·µ¢ œÜ)
           (cons (set-remove (set-remove œÜs œÜ·µ¢) œÜ)
                 œÜs*)]
          [#f (set-add œÜs œÜ)]))

      (: repeat-compact (‚àÄ (X) (‚Ñò X) X ((‚Ñò X) X ‚Üí (U (‚Ñò X) (Pairof (‚Ñò X) (‚Ñò X)))) ‚Üí (‚Ñò X)))
      ;; FIXME code duplicate
      (define (repeat-compact xs x f)
        (let loop ([xs : (‚Ñò X) xs] [x : X x])
          (match (f xs x)
            [(cons xs‚ÇÅ xs‚ÇÇ)
             (for/fold ([acc : (‚Ñò X) xs‚ÇÅ]) ([x xs‚ÇÇ])
               (loop acc x))]
            [(? set? s) s])))

      (repeat-compact œÜs œÜ iter))
    
    (for/fold ([Œì : -Œì Œì])
              ([t ts]
               #:when t
               ;#:unless (set-empty? (fv‚Çú t))
               )
      (define t*
        (match t
          [(-t.@ 'not (list (-t.@ 'not (list t*)))) t*]
          [_ t]))
      (œÜs+ Œì t*)))

  (define (Œì++ [Œì : -Œì] [œÜs : -Œì]) : -Œì (apply Œì+ Œì (set->list œÜs)))

  (: œÉ‚äï! : -Œ£ -Œì ‚ü™Œ±‚ü´ -W¬π ‚Üí Void)
  (define (œÉ‚äï! Œ£ Œì ‚ü™Œ±‚ü´ W)
    (match-define (-W¬π V t) W)
    (define V* (V+ (-Œ£-œÉ Œ£) V (predicates-of Œì t)))
    (œÉ‚äïV! Œ£ ‚ü™Œ±‚ü´ V*))  

  (: œÉ‚äïV! : -Œ£ ‚ü™Œ±‚ü´ -V ‚Üí Void)
  (define (œÉ‚äïV! Œ£ Œ± V)
    (set--Œ£-œÉ! Œ£ (œÉ‚äï (-Œ£-œÉ Œ£) Œ± V)))

  (: œÉ‚äïVs! : -Œ£ ‚ü™Œ±‚ü´ (‚Ñò -V) ‚Üí Void)
  (define (œÉ‚äïVs! Œ£ Œ± Vs)
    (define œÉ*
      (hash-update (-Œ£-œÉ Œ£)
                   Œ±
                   (Œª ([Vs‚ÇÄ : (‚Ñò -V)])
                     (cond [(set-empty? Vs‚ÇÄ) Vs] ; fast special case
                           [else
                            (for/fold ([Vs* : (‚Ñò -V) Vs‚ÇÄ])
                                      ([V (in-set Vs)])
                              (Vs‚äï (-Œ£-œÉ Œ£) Vs* V))]))
                   mk-‚àÖ))
    (set--Œ£-œÉ! Œ£ œÉ*))

  (: œÉ-copy! : -Œ£ ‚ü™Œ±‚ü´ ‚ü™Œ±‚ü´ ‚Üí Void)
  (define (œÉ-copy! Œ£ Œ±-src Œ±-tgt)
    (unless (equal? Œ±-src Œ±-tgt)
      (œÉ‚äïVs! Œ£ Œ±-tgt (œÉ@ Œ£ Œ±-src))))

  (: œÉ‚äï : -œÉ ‚ü™Œ±‚ü´ -V ‚Üí -œÉ)
  (define (œÉ‚äï œÉ Œ± V)
    (match (‚ü™Œ±‚ü´->-Œ± Œ±)
      ; TODO just debugging. Shouldn't happen
      [(-Œ±.imm V*)
       (unless (equal? V V*)
         (error 'œÉ‚äï "illegal allocation: ~a ‚Ü¶ ~a~n" (show-V V*) (show-V V)))
       œÉ]
      [_
       (hash-update œÉ Œ± (Œª ([Vs : (‚Ñò -V)]) (Vs‚äï œÉ Vs V)) mk-‚àÖ)]))

  ;; Widen value set with new value
  (define (Vs‚äï [œÉ : -œÉ] [Vs : (‚Ñò -V)] [V : (U -V (‚Ñò -V))]) : (‚Ñò -V)
    (: iter : (‚Ñò -V) -V ‚Üí (U (‚Ñò -V) (Pairof (‚Ñò -V) -V)))
    (define (iter Vs V)
      (match (for/or : (Option (List -V -V -V)) ([V·µ¢ Vs])
               (cond [(V‚äï œÉ V·µ¢ V) => (Œª ([V* : -V]) (list V* V·µ¢ V))]
                     [else #f]))
        [(list V* V‚ÇÅ V‚ÇÇ)
         (cons (set-remove (set-remove Vs V‚ÇÅ) V‚ÇÇ)
               V*)]
        [#f (set-add Vs V)]))

    (: repeat-compact (‚àÄ (X) (‚Ñò X) X ((‚Ñò X) X ‚Üí (U (‚Ñò X) (Pairof (‚Ñò X) X))) ‚Üí (‚Ñò X)))
    (define (repeat-compact xs x f)
      (let loop ([xs : (‚Ñò X) xs] [x : X x])
        (match (f xs x)
          [(cons xs* x*) (loop xs* x*)]
          [(? set? s) s])))

    (cond [(-V? V) (repeat-compact Vs V iter)]
          [else (for/fold ([Vs* : (‚Ñò -V) Vs])
                          ([V·µ¢ (in-set V)])
                  (repeat-compact Vs V·µ¢ iter))]))

  (: V+ : -œÉ -V (U -V -h (‚Ñò -h)) ‚Üí -V)
  ;; Refine opaque value with predicate
  (define (V+ œÉ V P)
    
    (define (simplify [P : -V]) : -V
      (match P
        [(-Ar _ (and Œ± (app ‚ü™Œ±‚ü´->-Œ± (or (? -Œ±.wrp?) (? -e?)))) _)
         (define Vs (œÉ@ œÉ Œ±))
         (cond [(= 1 (set-count Vs)) (simplify (set-first Vs))]
               [else P])]
        [(-St/C _ ùíæ _) (-st-p ùíæ)]
        [(or (? -Vectorof?) (? -Vector/C?)) 'vector?]
        [_ P]))
    
    (cond
      [(set? P)
       (for/fold ([V : -V V]) ([P·µ¢ (in-set P)])
         (V+ œÉ V P·µ¢))]
      [else
       (with-debugging/off
         ((V*)
          (match V
            [(-‚óè ps)
             (match P
               [(or (-‚â°/c b) (-b b)) (-b b)]
               ['not -ff]
               ['null? -null]
               ['void? -void]
               [(? -h? h) (-‚óè (ps+ ps h))]
               [(? -V? P)
                (match (simplify P)
                  [(? -o? o) (-‚óè (ps+ ps o))]
                  [_ V])])]
            [_ V]))
         
         (hash-ref! printing (list V P)
                    (Œª ()
                      (printf "~a + ~a -> ~a~n"
                              (show-V V)
                              (if (-v? P) (show-e P) (show-V P))
                              (show-V V*)))))]))

  ;; Combine 2 predicates for a more precise one.
  ;; Return `#f` if there's no single predicate that refines both
  (define p+ : (-h -h ‚Üí (Option (‚Ñò -h)))
    (match-lambda**/symmetry
     [(p q) #:when (equal? '‚úì (p‚áíp p q)) {set p}]
     [((or 'exact-integer? 'exact-nonnegative-integer?)
       (-‚â•/c (and (? (between/c 0 1)) (not 0))))
      {set 'exact-positive-integer?}]
     [((or 'exact-integer? 'exact-nonnegative-integer?)
       (->/c (and (? (between/c 0 1)) (not 1))))
      {set 'exact-positive-integer?}]
     [('exact-integer? (-‚â•/c (and (? (between/c -1 0)) (not -1))))
      {set 'exact-nonnegative-integer?}]
     [('exact-integer? (->/c (and (? (between/c -1 0)) (not  0))))
      {set 'exact-nonnegative-integer?}]
     [('exact-nonnegative-integer? (-not/c (-‚â°/c 0)))
      {set 'exact-positive-integer?}]
     [('exact-nonnegative-integer? (-‚â¢/c 0))
      {set 'exact-positive-integer?}]
     [('list? (-not/c 'null?)) {set 'list? -cons?}]
     [('list? (-not/c -cons?)) {set 'null?}]
     [(_ _) #f]))

  ;; Strengthen refinement set with new predicate
  (define (ps+ [ps : (‚Ñò -h)] [p : -h]) : (‚Ñò -h)

    (: iter : (‚Ñò -h) -h ‚Üí (U (‚Ñò -h) (Pairof (‚Ñò -h) (‚Ñò -h))))
    (define (iter ps p)
      (match (for/or : (Option (List (‚Ñò -h) -h -h)) ([p·µ¢ ps])
               (cond [(p+ p·µ¢ p) => (Œª ([ps* : (‚Ñò -h)]) (list ps* p·µ¢ p))]
                     [else #f]))
        [(list ps* p·µ¢ p)
         (cons (set-remove (set-remove ps p·µ¢) p)
               ps*)]
        [#f (set-add ps p)]))

    (: repeat-compact (‚àÄ (X) (‚Ñò X) X ((‚Ñò X) X ‚Üí (U (‚Ñò X) (Pairof (‚Ñò X) (‚Ñò X)))) ‚Üí (‚Ñò X)))
    (define (repeat-compact xs x f)
      (let loop ([xs : (‚Ñò X) xs] [x : X x])
        (match (f xs x)
          [(cons xs‚ÇÅ xs‚ÇÇ)
           (for/fold ([acc : (‚Ñò X) xs‚ÇÅ]) ([x xs‚ÇÇ])
             (loop acc x))]
          [(? set? s) s])))

    (case p
      [(any/c) ps] ; TODO tmp hack. How did this happen?
      [else (repeat-compact ps p iter)]))

  (define œÜ+ : (-t -t ‚Üí (Option -Œì))
    (match-lambda**/symmetry ; FIXME inefficiency, there's no e‚ä¢e
     [(œÜ œà) #:when (equal? '‚úì (Œì‚ä¢t {set œÜ} œà)) {set œÜ}]
     [(_ _) #f]))

  ;; Widen 2 values to one approximating both.
  ;; Return `#f` if no approximation preferred
  (define (V‚äï [œÉ : -œÉ] [V‚ÇÅ : -V] [V‚ÇÇ : -V]) : (Option -V)
    (with-debugging ((V*) (match* (V‚ÇÅ V‚ÇÇ)
                            [(_ _) #:when (V‚äë œÉ V‚ÇÇ V‚ÇÅ) V‚ÇÅ]
                            [(_ _) #:when (V‚äë œÉ V‚ÇÅ V‚ÇÇ) V‚ÇÇ]
                            ; TODO more heuristics
                            [((-b b‚ÇÅ) (-b b‚ÇÇ)) #:when (not (equal? b‚ÇÅ b‚ÇÇ))
                             (define-syntax-rule (check-for-base-types p? ...)
                               (cond
                                 [(and (p? b‚ÇÅ) (p? b‚ÇÇ)) (-‚óè {set 'p?})] ...
                                 [else #f]))

                             (check-for-base-types
                              exact-positive-integer? exact-nonnegative-integer? exact-integer?
                              integer? real? number?
                              path-string? string?
                              char? boolean?
                              regexp? pregexp? byte-regexp? byte-pregexp?)]
                            [((? -b? b) (-‚óè ps))
                             (define ps*
                               (for/set: : (‚Ñò -h) ([p (in-set ps)]
                                                   #:when (equal? '‚úì (p‚àãVs œÉ p b)))
                                 p))
                             ;; guard non-empty set means heuristic, that they're "compatible"
                             (and (not (set-empty? ps*)) (-‚óè ps*))]
                            [((-‚óè ps) (-‚óè qs))
                             (define ps* (ps‚äï ps qs))
                             (if (set-empty? ps*) #|just a heuristic|# #f (-‚óè ps*))]
                            [(_ _) #f]))
      (when (or (let ([‚óè? (Œª (V) (and (-V? V) (equal? V (-‚óè ‚àÖ))))])
                  (and (‚óè? V*) (not (‚óè? V‚ÇÅ)) (not (‚óè? V‚ÇÇ)))))
        (printf "Warning: ~a ‚äï ~a = ~a~n~n" (show-V V‚ÇÅ) (show-V V‚ÇÇ) (show-V V*)))))

  ;; Return refinement set that's an over-approximation of both sets
  (define (ps‚äï [ps‚ÇÅ : (‚Ñò -h)] [ps‚ÇÇ : (‚Ñò -h)]) : (‚Ñò -h)
    (for*/union : (‚Ñò -h) ([p‚ÇÅ ps‚ÇÅ] [p‚ÇÇ ps‚ÇÇ]) (p‚äï p‚ÇÅ p‚ÇÇ)))

  ;; Return predicate that's weaker than both
  (define p‚äï : (-h -h ‚Üí (‚Ñò -h))
    (match-lambda**/symmetry
     [(p q) #:when (equal? '‚úì (p‚áíp q p)) {set p}]
     [(_ _) ‚àÖ]))

  ;; Check if `V‚ÇÇ` definitely subsumes `V‚ÇÅ`
  ;; `#f` is a conservative "don't know" answer
  (define (V‚äë [œÉ : -œÉ] [V‚ÇÅ : -V] [V‚ÇÇ : -V]) : Boolean

    (define-set seen : (Pairof ‚ü™Œ±‚ü´ ‚ü™Œ±‚ü´) #:as-mutable-hash? #t)

    (: go/‚ü™Œ±‚ü´ : ‚ü™Œ±‚ü´ ‚ü™Œ±‚ü´ ‚Üí Boolean)
    (define (go/‚ü™Œ±‚ü´ Œ±‚ÇÅ Œ±‚ÇÇ)
      (cond
        [(equal? Œ±‚ÇÅ Œ±‚ÇÇ) #t]
        [else
         (define Œ±‚ÇÅŒ±‚ÇÇ (cons Œ±‚ÇÅ Œ±‚ÇÇ))
         (cond
           [(seen-has? Œ±‚ÇÅŒ±‚ÇÇ) #t]
           [else
            (seen-add! Œ±‚ÇÅŒ±‚ÇÇ)
            (define Vs‚ÇÅ (œÉ@ œÉ Œ±‚ÇÅ))
            (define Vs‚ÇÇ (œÉ@ œÉ Œ±‚ÇÇ))
            (for/and : Boolean ([V‚ÇÅ (in-set Vs‚ÇÅ)])
              (for/or : Boolean ([V‚ÇÇ (in-set Vs‚ÇÇ)])
                (go V‚ÇÅ V‚ÇÇ)))])]))

    (: go : -V -V ‚Üí Boolean)
    (define (go V‚ÇÅ V‚ÇÇ)
      (match* (V‚ÇÅ V‚ÇÇ)
        [(V V) #t]
        [(_ (-‚óè ps)) #:when (not (behavioral? œÉ V‚ÇÅ))
         (for/and : Boolean ([p ps])
           (equal? '‚úì (p‚àãVs œÉ p V‚ÇÅ)))]
        [((-St ùíæ Œ±s‚ÇÅ) (-St ùíæ Œ±s‚ÇÇ)) #:when (struct-all-immutable? ùíæ)
         (for/and : Boolean ([Œ±‚ÇÅ : ‚ü™Œ±‚ü´ Œ±s‚ÇÅ] [Œ±‚ÇÇ : ‚ü™Œ±‚ü´ Œ±s‚ÇÇ])
           (go/‚ü™Œ±‚ü´ Œ±‚ÇÅ Œ±‚ÇÇ))]
        [((-Clo _ ‚ü¶e‚üß œÅ‚ÇÅ _)
          (-Clo _ ‚ü¶e‚üß œÅ‚ÇÇ _)) ; TODO : ignore `Œì` ok?
         (for/and : Boolean ([(x Œ±‚ÇÅ) (in-hash œÅ‚ÇÅ)])
           (define Œ±‚ÇÇ (œÅ@ œÅ‚ÇÇ x))
           (or (and (-V? Œ±‚ÇÅ) (-V? Œ±‚ÇÇ) (go Œ±‚ÇÅ Œ±‚ÇÇ))
               (and (not (-V? Œ±‚ÇÅ)) (not (-V? Œ±‚ÇÇ)) (go/‚ü™Œ±‚ü´ Œ±‚ÇÅ Œ±‚ÇÇ))))]
        [(_ _) #f]))

    (go V‚ÇÅ V‚ÇÇ))

  (define (œÜs‚äë [œÜs‚ÇÅ : -Œì] [œÜs‚ÇÇ : -Œì]) : Boolean (‚äÜ œÜs‚ÇÇ œÜs‚ÇÅ))

  (: Œì‚äë : -Œì -Œì ‚Üí Boolean)
  (define (Œì‚äë Œì‚ÇÅ Œì‚ÇÇ) (‚äÜ Œì‚ÇÇ Œì‚ÇÅ))

  (define (?Œì‚äî [Œì‚ÇÅ : -Œì] [Œì‚ÇÇ : -Œì]) : (Option -Œì)
    (define-values (Œì* Œ¥Œì‚ÇÅ Œ¥Œì‚ÇÇ) (set-intersect/differences Œì‚ÇÅ Œì‚ÇÇ))
    (cond [(and (= 1 (set-count Œ¥Œì‚ÇÅ))
                (= 1 (set-count Œ¥Œì‚ÇÇ)))
           (define œÜ‚ÇÅ (set-first Œ¥Œì‚ÇÅ))
           (define œÜ‚ÇÇ (set-first Œ¥Œì‚ÇÇ))
           (cond [(complement? œÜ‚ÇÅ œÜ‚ÇÇ) Œì*]
                 [(Œì‚ä¢t {set œÜ‚ÇÅ} œÜ‚ÇÇ) Œì‚ÇÇ]
                 [(Œì‚ä¢t {set œÜ‚ÇÇ} œÜ‚ÇÅ) Œì‚ÇÅ]
                 [else #f])]
          [else #f]))

  (define ((?ŒìA‚äî [œÉ : -œÉ]) [ŒìA‚ÇÅ : -ŒìA] [ŒìA‚ÇÇ : -ŒìA]) : (Option -ŒìA)

    (: A‚äë : -œÉ -A -A ‚Üí Boolean)
    (define (A‚äë œÉ A‚ÇÅ A‚ÇÇ)
      (match* (A‚ÇÅ A‚ÇÇ)
        [((-W Vs‚ÇÅ s‚ÇÅ) (-W Vs‚ÇÇ s‚ÇÇ))
         (and (equal? s‚ÇÅ s‚ÇÇ)
              (= (length Vs‚ÇÅ) (length Vs‚ÇÇ))
              (for/and : Boolean ([V‚ÇÅ Vs‚ÇÅ] [V‚ÇÇ Vs‚ÇÇ])
                (V‚äë œÉ V‚ÇÅ V‚ÇÇ)))]
        [((? -blm? blm‚ÇÅ) (? -blm? blm‚ÇÇ))
         (equal? blm‚ÇÅ blm‚ÇÇ)]
        [(_ _) #f]))

    (: ŒìA‚äë : -ŒìA -ŒìA ‚Üí Boolean)
    (define (ŒìA‚äë ŒìA‚ÇÅ ŒìA‚ÇÇ)
      (match-define (-ŒìA Œì‚ÇÅ A‚ÇÅ) ŒìA‚ÇÅ)
      (match-define (-ŒìA Œì‚ÇÇ A‚ÇÇ) ŒìA‚ÇÇ)
      (and (œÜs‚äë Œì‚ÇÅ Œì‚ÇÇ) (A‚äë œÉ A‚ÇÅ A‚ÇÇ)))
    
    (cond [(ŒìA‚äë ŒìA‚ÇÅ ŒìA‚ÇÇ) ŒìA‚ÇÇ]
          [(ŒìA‚äë ŒìA‚ÇÇ ŒìA‚ÇÅ) ŒìA‚ÇÅ]
          [else
           (match-define (-ŒìA Œì‚ÇÅ A‚ÇÅ) ŒìA‚ÇÅ)
           (match-define (-ŒìA Œì‚ÇÇ A‚ÇÇ) ŒìA‚ÇÇ)
           (define ?Œì (and (equal? A‚ÇÅ A‚ÇÇ) (?Œì‚äî Œì‚ÇÅ Œì‚ÇÇ)))
           (and ?Œì (-ŒìA ?Œì A‚ÇÇ))]))

  (define (œÉ‚Çñ‚äï! [Œ£ : -Œ£] [Œ±‚Çñ : -Œ±‚Çñ] [Œ∫ : -Œ∫]) : Void
    (set--Œ£-œÉ‚Çñ! Œ£ (œÉ‚Çñ‚äï (-Œ£-œÉ‚Çñ Œ£) Œ±‚Çñ Œ∫)))

  (define (œÉ‚Çñ‚äï [œÉ‚Çñ : -œÉ‚Çñ] [Œ±‚Çñ : -Œ±‚Çñ] [Œ∫ : -Œ∫]) : -œÉ‚Çñ
    (hash-update œÉ‚Çñ Œ±‚Çñ (set-add/compact Œ∫ ?Œ∫‚äî) mk-‚àÖ))

  (: œÉ‚Çñ+! : -Œ£ -Œ±‚Çñ -Œ∫ ‚Üí -Œ±‚Çñ)
  (define (œÉ‚Çñ+! Œ£ Œ±‚Çñ Œ∫)
    (define Œû (-Œ£-Œû Œ£))
    (define-values (ctx pth) (Œ±‚Çñ->ctx+pth Œ±‚Çñ))
    (define pths‚ÇÄ (hash-ref Œû ctx mk-‚àÖ))
    (define ?pth
      (for/or : (U #f -Œ±‚Çñ:pth (‚Ñò -Œ±‚Çñ:pth)) ([pth‚ÇÄ (in-set pths‚ÇÄ)])
        (cond [(Œ±‚Çñ:pth‚äë pth pth‚ÇÄ) pth‚ÇÄ]
              [(Œ±‚Çñ:pth‚äë pth‚ÇÄ pth)
               (for/set: : (‚Ñò -Œ±‚Çñ:pth) ([pth‚ÇÄ* (in-set pths‚ÇÄ)]
                                        #:when (or (eq? pth‚ÇÄ* pth‚ÇÄ) (Œ±‚Çñ:pth‚äë pth‚ÇÄ* pth)))
                 pth‚ÇÄ*)]
              [else #f])))
    (define-values (pth* pths*)
      (cond
        [(set? ?pth) (values pth (set-add (set-subtract pths‚ÇÄ ?pth) pth))]
        [(-Œ±‚Çñ:pth? ?pth) (values ?pth pths‚ÇÄ)]
        [else (values pth (set-add pths‚ÇÄ pth))]))
    (define Œ±‚Çñ* (ctx+pth->Œ±‚Çñ ctx pth*))
    (set--Œ£-Œû! Œ£ (hash-set Œû ctx pths*))
    (œÉ‚Çñ‚äï! Œ£ Œ±‚Çñ* Œ∫)
    Œ±‚Çñ*)

  (: Œ±‚Çñ:pth‚äë : -Œ±‚Çñ:pth -Œ±‚Çñ:pth ‚Üí Boolean)
  (define Œ±‚Çñ:pth‚äë
    (match-lambda**
     [((-Œ±‚Çñ:pth $‚ÇÄ Œì‚ÇÄ) (-Œ±‚Çñ:pth $‚ÇÅ Œì‚ÇÅ))
      (and ($‚äë $‚ÇÄ $‚ÇÅ) (Œì‚äë Œì‚ÇÄ Œì‚ÇÅ))]))

  (: $‚äë : -$ -$ ‚Üí Boolean)
  (define ($‚äë $‚ÇÄ $‚ÇÅ)
    (for/and : Boolean ([(l t) (in-hash $‚ÇÅ)])
      (equal? t (hash-ref $‚ÇÄ l #f))))

  (: ?Œ∫‚äî : -Œ∫ -Œ∫ ‚Üí (Option -Œ∫))
  (define (?Œ∫‚äî Œ∫‚ÇÅ Œ∫‚ÇÇ)

    (: t‚äë : -?t -?t ‚Üí Boolean)
    (define (t‚äë t‚ÇÅ t‚ÇÇ)
      (implies t‚ÇÇ (equal? t‚ÇÅ t‚ÇÇ)))

    (: Œ∫‚äë : -Œ∫.rt -Œ∫.rt ‚Üí Boolean)
    (define (Œ∫‚äë Œ∫‚ÇÅ Œ∫‚ÇÇ)
      (match-define (-Œ∫.rt ‚ü¶k‚üß‚ÇÅ dom‚ÇÅ Œì‚ÇÅ t‚ÇÅ looped?‚ÇÅ) Œ∫‚ÇÅ)
      (match-define (-Œ∫.rt ‚ü¶k‚üß‚ÇÇ dom‚ÇÇ Œì‚ÇÇ t‚ÇÇ looped?‚ÇÇ) Œ∫‚ÇÇ)
      (and (‚ü¶k‚üß‚ÇÅ . equal? . ‚ü¶k‚üß‚ÇÇ)
           (dom‚ÇÇ . ‚äÜ  . dom‚ÇÅ)
           (Œì‚ÇÇ   . ‚äÜ  . Œì‚ÇÅ)
           (t‚ÇÅ   . t‚äë . t‚ÇÇ)
           (looped?‚ÇÅ . implies . looped?‚ÇÇ)))

    (match* (Œ∫‚ÇÅ Œ∫‚ÇÇ)
      [((-Œ∫.rt ‚ü¶k‚üß‚ÇÅ dom‚ÇÅ Œì‚ÇÅ t‚ÇÅ looped?‚ÇÅ)
        (-Œ∫.rt ‚ü¶k‚üß‚ÇÇ dom‚ÇÇ Œì‚ÇÇ t‚ÇÇ looped?‚ÇÇ))
       (cond [(Œ∫‚äë Œ∫‚ÇÅ Œ∫‚ÇÇ) Œ∫‚ÇÇ]
             [(Œ∫‚äë Œ∫‚ÇÇ Œ∫‚ÇÅ) Œ∫‚ÇÇ]
             [(and (equal? ‚ü¶k‚üß‚ÇÅ ‚ü¶k‚üß‚ÇÇ)
                   (t‚ÇÅ . t‚äë . t‚ÇÇ)
                   (dom‚ÇÇ . ‚äÜ . dom‚ÇÅ)
                   (looped?‚ÇÅ . implies . looped?‚ÇÇ))
              (define ?Œì (?Œì‚äî Œì‚ÇÅ Œì‚ÇÇ))
              (and ?Œì (-Œ∫.rt ‚ü¶k‚üß‚ÇÇ dom‚ÇÇ ?Œì t‚ÇÇ looped?‚ÇÇ))]
             [else #f])]
      [(Œ∫ Œ∫) Œ∫]
      [(_ _) #f]))

  (define (add-leak! [Œ£ : -Œ£] [V : -V]) : Void
    (when (behavioral? (-Œ£-œÉ Œ£) V)
      (œÉ‚äïV! Œ£ ‚ü™Œ±‚ü´‚Çï·µ• V)))

  (: alloc-init-args! :
     -Œ£ -$ -Œì -œÅ -‚ü™‚Ñã‚ü´ (Listof Symbol) (Listof -W¬π) Boolean ‚Üí (Values -œÅ -$))
  (define (alloc-init-args! Œ£ $ Œì œÅ ‚ü™‚Ñã‚ü´ xs Ws looped?)
    (define œÅ* (œÅ+ œÅ -x-dummy (-Œ±->‚ü™Œ±‚ü´ (-Œ±.fv ‚ü™‚Ñã‚ü´))))
    (bind-args! Œ£ $ Œì œÅ* ‚ü™‚Ñã‚ü´ xs Ws looped?))

  (: bind-args! : -Œ£ -$ -Œì -œÅ -‚ü™‚Ñã‚ü´ (Listof Symbol) (Listof -W¬π) Boolean ‚Üí (Values -œÅ -$))
  (define (bind-args! Œ£ $ Œì œÅ ‚ü™‚Ñã‚ü´ xs Ws looped?)
    (define œÉ (-Œ£-œÉ Œ£))
    (define-values (œÅ* $* canon)
      (for/fold ([œÅ : -œÅ œÅ] [$ : -$ $] [canon : (Immutable-HashTable -t Symbol) (hash)])
                ([x xs] [W‚Çì Ws])
        (match-define (-W¬π V‚Çì t‚Çì) W‚Çì)
        (define V‚Çì* (V+ œÉ V‚Çì (predicates-of Œì t‚Çì)))
        (define-values (t‚Çì* canon*)
          (cond [(not t‚Çì) (values (-t.x x) canon)]
                [(not looped?) (values t‚Çì canon)]
                [(hash-ref canon t‚Çì #f) => (Œª ([y : Symbol]) (values (-t.x y) canon))]
                [else (values (-t.x x) (hash-set canon t‚Çì x))]))
        (define Œ± (hash-ref œÅ x #|in case of letrec|#
                            (Œª () (-Œ±->‚ü™Œ±‚ü´ (-Œ±.x x ‚ü™‚Ñã‚ü´ (predicates-of-V V‚Çì*))))))
        (œÉ‚äïV! Œ£ Œ± V‚Çì*)
        (define $* (if t‚Çì* ($-set $ x t‚Çì*) $))
        (values (œÅ+ œÅ x Œ±) $* canon*)))
    (values œÅ* $*))

  (: alloc-rest-args! ([-Œ£ -Œì -‚ü™‚Ñã‚ü´ ‚Ñì (Listof -W¬π)] [#:end -V] . ->* . -V))
  (define (alloc-rest-args! Œ£ Œì ‚ü™‚Ñã‚ü´ ‚Ñì Ws #:end [V‚Çô -null])

    (: precise-alloc! ([(Listof -W¬π)] [Natural] . ->* . -V))
    ;; Allocate vararg list precisely, preserving length
    (define (precise-alloc! Ws [i 0])
      (match Ws
        [(list) V‚Çô]
        [(cons W‚Çï Ws*)
         (define Œ±‚Çï (-Œ±->‚ü™Œ±‚ü´ (-Œ±.var-car ‚Ñì ‚ü™‚Ñã‚ü´ i)))
         (define Œ±‚Çú (-Œ±->‚ü™Œ±‚ü´ (-Œ±.var-cdr ‚Ñì ‚ü™‚Ñã‚ü´ i)))
         (œÉ‚äï! Œ£ Œì Œ±‚Çï W‚Çï)
         (œÉ‚äïV! Œ£ Œ±‚Çú (precise-alloc! Ws* (+ 1 i)))
         (-Cons Œ±‚Çï Œ±‚Çú)]))
    
    ;; Allocate length up to 2 precisely to let `splay` to go through
    ;; This is because `match-lambda*` expands to varargs with specific
    ;; expectation of arities
    (match Ws
      [(or (list) (list _) (list _ _) (list _ _ _))
       (precise-alloc! Ws)]
      [(? pair?)
       (define Œ±‚Çï (-Œ±->‚ü™Œ±‚ü´ (-Œ±.var-car ‚Ñì ‚ü™‚Ñã‚ü´ #f)))
       (define Œ±‚Çú (-Œ±->‚ü™Œ±‚ü´ (-Œ±.var-cdr ‚Ñì ‚ü™‚Ñã‚ü´ #f)))
       (define V‚Çú (-Cons Œ±‚Çï Œ±‚Çú))
       ;; Allocate spine for var-arg lists
       (œÉ‚äïV! Œ£ Œ±‚Çú V‚Çú)
       (œÉ‚äïV! Œ£ Œ±‚Çú V‚Çô)
       ;; Allocate elements in var-arg lists
       (for ([W Ws])
         (œÉ‚äï! Œ£ Œì Œ±‚Çï W))
       V‚Çú]))

  (: estimate-list-lengths : -œÉ -V ‚Üí (‚Ñò (U #f Arity)))
  ;; Estimate possible list lengths from the object language's abstract list
  (define (estimate-list-lengths œÉ V)
    (define-set seen : ‚ü™Œ±‚ü´ #:eq? #t #:as-mutable-hash? #t)
    (define maybe-non-proper-list? : Boolean #f)

    (: arity-inc : Arity ‚Üí Arity)
    (define arity-inc
      (match-lambda
        [(? exact-integer? n) (+ 1 n)]
        [(arity-at-least n) (arity-at-least (+ 1 n))]))
    
    (: go! : -V ‚Üí (‚Ñò Arity))
    (define go!
      (match-lambda
        [(-Cons _ Œ±‚Çú)
         (cond [(seen-has? Œ±‚Çú) {set (arity-at-least 0)}]
               [else (seen-add! Œ±‚Çú)
                     (for/union : (‚Ñò Arity) ([V‚Çú (in-set (œÉ@ œÉ Œ±‚Çú))])
                        (map/set arity-inc (go! V‚Çú)))])]
        [(-b '()) {set 0}]
        [(-‚óè ps) #:when (‚àã ps 'list?) {set (arity-at-least 0)}]
        [_ (set! maybe-non-proper-list? #t)
           ‚àÖ]))
    (define res
      (match (normalize-arity (set->list (go! V)))
        [(? list? l) (list->set l)]
        [a {set a}]))
    (if maybe-non-proper-list? (set-add res #f) res))

  (: unalloc : -œÉ -V ‚Üí (‚Ñò (Option (Listof -V))))
  ;; Convert a list in the object language into list(s) in the meta language
  (define (unalloc œÉ V)
    (define-set seen : ‚ü™Œ±‚ü´ #:eq? #t #:as-mutable-hash? #t)
    (define Tail {set '()})
    (: go! : -V ‚Üí (‚Ñò (Listof -V)))
    (define go!
      (match-lambda
        [(-Cons Œ±‚Çï Œ±‚Çú)
         (cond
           [(seen-has? Œ±‚Çú) Tail]
           [else
            (seen-add! Œ±‚Çú)
            (define tails
              (for/union : (‚Ñò (Listof -V)) ([V‚Çú (in-set (œÉ@ œÉ Œ±‚Çú))])
                 (go! V‚Çú)))
            (define heads (œÉ@ œÉ Œ±‚Çï))
            (for*/set: : (‚Ñò (Listof -V)) ([head (in-set heads)] [tail (in-set tails)])
              (cons head tail))])]
        [(-b (list)) Tail]
        [_ ‚àÖ]))

    ;; FIXME this list is complete and can result in unsound analysis
    ;; Need to come up with a nice way to represent an infinite family of lists
    (go! V))

  (: unalloc-prefix : -œÉ -V Natural ‚Üí (‚Ñò (Pairof (Listof -V) -V)))
  (define (unalloc-prefix œÉ V n)
    (let go ([V : -V V] [n : Natural n])
      (cond
        [(<= n 0) {set (cons '() V)}]
        [else
         (match V
           [(-Cons Œ±‚Çï Œ±‚Çú)
            (define V‚Çïs (œÉ@ œÉ Œ±‚Çï))
            (define pairs
              (for/union : (‚Ñò (Pairof (Listof -V) -V)) ([V‚Çú (in-set (œÉ@ œÉ Œ±‚Çú))])
                         (go V‚Çú (- n 1))))
            (for*/set: : (‚Ñò (Pairof (Listof -V) -V)) ([V‚Çï (in-set V‚Çïs)]
                                                      [pair (in-set pairs)])
              (match-define (cons V‚Çús V·µ£) pair)
              (cons (cons V‚Çï V‚Çús) V·µ£))]
           [(-‚óè ps) #:when (‚àã ps 'list?)
            {set (cons (make-list n (+‚óè)) (+‚óè 'list?))}]
           [_ ‚àÖ])])))

  (: M‚äï! : -Œ£ -Œ±‚Çñ -ŒìA ‚Üí Void)
  (define (M‚äï! Œ£ Œ±‚Çñ ŒìA)
    (set--Œ£-M! Œ£ (hash-update (-Œ£-M Œ£) Œ±‚Çñ (Œª ([ans : (‚Ñò -ŒìA)]) (set-add ans ŒìA)) mk-‚àÖ)))

  (: copy-Œì : (‚Ñò Symbol) -Œì -Œì ‚Üí -Œì)
  (define (copy-Œì dom Œì‚Çú Œì‚Çõ)
    (‚à™ Œì‚Çú (Œì‚Üì Œì‚Çõ dom)))
  )


(define-syntax match-lambda**/symmetry
  ;; b/c TR doesn't work well with `match-lambda*` and `list-no-order`
  (syntax-parser
    [(_ clauses ... [((~literal _) (~literal _)) dflt ...])
     (define doubled-clauses
       (append-map
        (Œª (clause)
          (with-syntax ([[(x y) e ...] clause])
            (list #'[(x y) e ...] #'[(y x) e ...])))
        (syntax->list #'(clauses ...))))
     #`(match-lambda** #,@doubled-clauses [(_ _) dflt ...])]))
