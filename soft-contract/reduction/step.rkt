#lang typed/racket/base

(provide ev ev* co co* ‚áì‚Çö ‚áì‚Çò ‚áì)

(require
 racket/match racket/set
 "../utils/main.rkt" "../ast/definition.rkt" "../runtime/main.rkt" "../proof-relation/main.rkt" "continuation.rkt")

(: ev* : -M -Œû -œÉ (‚Ñò -‚Ñ¨) ‚Üí (Values -ŒîM -ŒîŒû -ŒîœÉ))
(define (ev* M Œû œÉ ‚Ñ¨s)
  (for/fold ([Œ¥M : -ŒîM ‚ä•M] [Œ¥Œû : -ŒîŒû ‚ä•Œû] [Œ¥œÉ : -ŒîœÉ ‚ä•œÉ])
            ([‚Ñ¨ ‚Ñ¨s])
    (ev M Œû œÉ ‚Ñ¨)))

(: co* : -M -Œû -œÉ (‚Ñò -Co) ‚Üí (Values -ŒîM -ŒîŒû -ŒîœÉ))
(define (co* M Œû œÉ Cos)
  (for/fold ([Œ¥M : -ŒîM ‚ä•M] [Œ¥Œû : -ŒîŒû ‚ä•Œû] [Œ¥œÉ : -ŒîœÉ ‚ä•œÉ])
            ([Co Cos])
    (co M Œû œÉ Co)))

(: ev : -M -Œû -œÉ -‚Ñ¨ ‚Üí (Values -ŒîM -ŒîŒû -ŒîœÉ))
;; Execute function body `‚Ñ¨`
(define (ev M Œû œÉ ‚Ñ¨)
  (apply/values (collect M Œû ‚Ñ¨) ((-‚Ñ¨-code ‚Ñ¨) M œÉ ‚Ñ¨)))

(: co : -M -Œû -œÉ -Co ‚Üí (Values -ŒîM -ŒîŒû -ŒîœÉ))
;; Resume computation `‚Ñã[A]`, propagating errors and plugging values into hole.
(define (co M Œû œÉ Co)
  (match-define (-Co (-‚Ñõ ‚Ñ¨‚ÇÄ ‚Ñã‚ÇÄ) ‚Ñ¨ As) Co)
  (match-define (-‚Ñã Œì‚ÇÄ f bnds ‚Ñ∞) ‚Ñã‚ÇÄ)

  ;; Propagate errors and plug values into hole
  (define-values (ŒìWs ŒìEs)
    (let ()
      (printf "TODO: use path-conditions from caller+callee to eliminate spurious returns~n")
      
      (define args (map (inst cdr Symbol -s) bnds))
      (define fargs (apply -?@ f args))
      
      (for/fold ([ŒìWs : (‚Ñò -ŒìW) ‚àÖ] [ŒìEs : (‚Ñò -ŒìE) ‚àÖ])
                ([A As])
        (define Œì‚ÇÄ*
          (match-let ([(-Œì œÜs as Œ≥s) Œì‚ÇÄ]
                      [Œ≥ (-Œ≥ ‚Ñ¨ f bnds)])
            (-Œì œÜs as (set-add Œ≥s Œ≥))))
        (match A
          [(-ŒìW Œì (-W Vs s))
           (values (set-add ŒìWs (-ŒìW Œì‚ÇÄ* (-W Vs (and s fargs)))) ŒìEs)]
          [(-ŒìE Œì blm)
           (values ŒìWs (set-add ŒìEs (-ŒìE Œì‚ÇÄ* blm)))]))))
  
  (let ([col (collect M Œû ‚Ñ¨‚ÇÄ)])
    (‚äî¬≥ (apply/values col ((‚Ñ∞‚ü¶_‚üß ‚Ñ∞ ŒìWs) M œÉ ‚Ñ¨‚ÇÄ))
        (apply/values col (values ‚ä•œÉ ‚àÖ ŒìEs ‚àÖ)))))
  

(: ‚áì‚Çö : (Listof -module) -e ‚Üí -‚ü¶e‚üß)
;; Compile list of modules
(define (‚áì‚Çö ms e)
  (match ms
    ['() (‚áì e)]
    [(cons m ms*) ((‚Üù.modules (map ‚áì‚Çò ms*) (‚áì e)) (‚áì‚Çò m))]))

(: ‚áì‚Çò : -module ‚Üí -‚ü¶e‚üß)
;; Compile module
(define (‚áì‚Çò m)
  (match-define (-module p ds) m)
  
  (: ‚áìpc : -provide-spec ‚Üí -‚ü¶e‚üß)
  (define (‚áìpc spec)
    (match-define (-p/c-item x c) spec)
    ((‚Üù.dec (-id x p)) (‚áì c)))

  (: ‚áìd : -module-level-form ‚Üí -‚ü¶e‚üß)
  (define (‚áìd d)
    (match d
      [(-define-values _ xs e) ((‚Üù.def p xs) (‚áì e))]
      [(-provide _ specs) ((‚Üù.begin (map ‚áìpc specs)) ‚ü¶void‚üß)]
      [(? -e? e) (‚áì e)]
      [_
       (printf "‚áìd: ignore ~a~n" (show-module-level-form d))
       ‚ü¶void‚üß]))

  ((‚Üù.begin (map ‚áìd ds)) ‚ü¶void‚üß))

(: ‚áì : -e ‚Üí -‚ü¶e‚üß)
;; Compile expresion to computation
(define (‚áì e)
  (match e
    [(-Œª xs e*)
     (define ‚ü¶e*‚üß (‚áì e*))
     (Œª (M œÉ ‚Ñ¨)
       (match-define (-‚Ñ¨ _ œÅ Œì _) ‚Ñ¨)
       (values ‚ä•œÉ {set (-ŒìW Œì (-W (list (-Clo xs ‚ü¶e*‚üß œÅ Œì)) e))} ‚àÖ ‚àÖ))]
    [(-case-Œª body) (error '‚áì "TODO: case-Œª")]
    [(? -prim? p)
     (Œª (M œÉ ‚Ñ¨)
       (values ‚ä•œÉ {set (-ŒìW (-‚Ñ¨-cnd ‚Ñ¨) (-W (list p) p))} ‚àÖ ‚àÖ))]
    [(-‚Ä¢ i)
     (Œª (M œÉ ‚Ñ¨)
       (values ‚ä•œÉ {set (-ŒìW (-‚Ñ¨-cnd ‚Ñ¨) (-W -‚óè/Vs e))} ‚àÖ ‚àÖ))]
    [(-x x)
     (Œª (M œÉ ‚Ñ¨)
       (match-define (-‚Ñ¨ _ œÅ Œì ùíû) ‚Ñ¨)
       (define s (canonicalize Œì x))
       (define-values (ŒìWs ŒìEs)
         (for*/fold ([ŒìWs : (‚Ñò -ŒìW) ‚àÖ]
                     [ŒìEs : (‚Ñò -ŒìE) ‚àÖ])
                    ([V (œÉ@ œÉ (œÅ@ œÅ x))]
                     [W (in-value (-W (list V) s))]
                     #:unless (spurious? M œÉ Œì W))
           (case V
             [(undefined) ; spurious `undefined` should have been eliminated by `spurious?`
              (values
               ŒìWs
               (set-add
                ŒìEs
                (-ŒìE Œì (-blm 'TODO 'Œõ (list 'defined?) (list 'undefined)))))]
             [else (values (set-add ŒìWs (-ŒìW Œì W)) ŒìEs)])))
       (values ‚ä•œÉ ŒìWs ŒìEs ‚àÖ))]
    [(and ref (-ref (and id (-id name l-from)) l-ctx pos))
     (cond
       [(equal? l-from l-ctx)
        (Œª (M œÉ ‚Ñ¨)
          (define Œì (-‚Ñ¨-cnd ‚Ñ¨))
          (define ŒìWs
            (for/set: : (‚Ñò -ŒìW) ([V (œÉ@ œÉ (-Œ±.def id))])
              (define s (if (-o? V) V ref))
              (-ŒìW Œì (-W (list V) s))))
          (values ‚ä•œÉ ŒìWs ‚àÖ ‚àÖ))]
       [else
        (Œª (M œÉ ‚Ñ¨)
          (printf "FIXME: ignore `~a`'s contract for now.~n" (-id-name id))
          (define Œì (-‚Ñ¨-cnd ‚Ñ¨))
          (define ŒìWs
            (for/set: : (‚Ñò -ŒìW) ([V (œÉ@ œÉ (-Œ±.def id))])
              (define s (if (-o? V) V ref))
              (-ŒìW Œì (-W (list V) s))))
          (values ‚ä•œÉ ŒìWs ‚àÖ ‚àÖ))])]
    [(-@ f xs l)
     ((‚Üù.@ '() (map ‚áì xs) l) (‚áì f))]
    [(-if e‚ÇÄ e‚ÇÅ e‚ÇÇ)
     ((‚Üù.if (‚áì e‚ÇÅ) (‚áì e‚ÇÇ)) (‚áì e‚ÇÄ))]
    [(-wcm k v b)
     (error '‚áì "TODO: wcm")]
    [(-begin es)
     (match es
       [(cons e* es*) ((‚Üù.begin (map ‚áì es*)) (‚áì e*))]
       ['() ‚ü¶void‚üß])]
    [(-begin0 e‚ÇÄ es)
     ((‚Üù.begin0.v (map ‚áì es)) (‚áì e‚ÇÄ))]
    [(-quote q)
     (cond
       [(Base? q)
        (define b (-b q))
        (Œª (M œÉ ‚Ñ¨)
          (values ‚ä•œÉ {set (-ŒìW (-‚Ñ¨-cnd ‚Ñ¨) (-W (list b) b))} ‚àÖ ‚àÖ))]
       [else (error '‚áì "TODO: (quote ~a)" q)])]
    [(-let-values xs-es e l)
     (define ‚ü¶e‚üß (‚áì e))
     (define xs-‚ü¶e‚üßs
       (for/list : (Listof (Pairof (Listof Symbol) -‚ü¶e‚üß)) ([xs-e xs-es])
         (match-define (cons xs e‚Çì) xs-e)
         (cons xs (‚áì e‚Çì))))
     (match xs-‚ü¶e‚üßs 
       ['() ‚ü¶e‚üß]
       [(cons (cons xs‚ÇÄ ‚ü¶e‚üß‚ÇÄ) xs-‚ü¶e‚Çì‚üßs*)
        ((‚Üù.let-values '() xs‚ÇÄ xs-‚ü¶e‚Çì‚üßs* ‚ü¶e‚üß l) ‚ü¶e‚üß‚ÇÄ)])]
    [(-letrec-values xs-es e l)
     (define ‚ü¶e‚üß (‚áì e))
     (define xs-‚ü¶e‚üßs
       (for/list : (Listof (Pairof (Listof Symbol) -‚ü¶e‚üß)) ([xs-e xs-es])
         (match-define (cons xs e‚Çì) xs-e)
         (cons xs (‚áì e‚Çì))))
     (match xs-‚ü¶e‚üßs
       ['() ‚ü¶e‚üß]
       [(cons (cons xs‚ÇÄ ‚ü¶e‚üß‚ÇÄ) xs-‚ü¶e‚üßs*)
        (Œª (M œÉ ‚Ñ¨)
          (define ùíû (-‚Ñ¨-hist ‚Ñ¨))
          (define-values (Œ¥œÉ Œ¥œÅ)
            (for*/fold ([Œ¥œÉ : -ŒîœÉ ‚ä•œÉ] [Œ¥œÅ : -ŒîœÅ ‚ä•œÅ])
                       ([xs-‚ü¶e‚üß xs-‚ü¶e‚üßs] [x (car xs-‚ü¶e‚üß)])
              (define Œ± (-Œ±.x x ùíû))
              (values (‚äî Œ¥œÉ Œ± 'undefined)
                      (hash-set Œ¥œÅ x Œ±))))
          (define œÉ* (‚äî/m œÉ Œ¥œÉ))
          (((‚Üù.letrec-values Œ¥œÅ xs‚ÇÄ xs-‚ü¶e‚üßs* ‚ü¶e‚üß l) ‚ü¶e‚üß‚ÇÄ) M œÉ* ‚Ñ¨))])]
    [(-set! x e*) ((‚Üù.set! x) (‚áì e*))]
    [(-@-havoc (-x x)) (‚Üù.havoc x)]
    [(-amb es)
     (define ‚ü¶e‚üßs (set-map es ‚áì))
     (Œª (M œÉ ‚Ñ¨)
       (for*/ans ([‚ü¶e‚üß ‚ü¶e‚üßs]) (‚ü¶e‚üß M œÉ ‚Ñ¨)))]
    [(-Œº/c x c) ((‚Üù.Œº/c x) (‚áì c))]
    [(-->i cs (and mk-d (-Œª xs d)) l)
     (define ‚ü¶d‚üß (‚áì d))
     (match (map ‚áì cs)
       ['()
        (define c (-?->i '() mk-d))
        (Œª (M œÉ ‚Ñ¨)
          (match-define (-‚Ñ¨ _ œÅ Œì _) ‚Ñ¨)
          (define Mk-D (-W¬π (-Clo xs ‚ü¶d‚üß œÅ Œì) mk-d))
          (mk-=>i Œì '() Mk-D l))]
       [(cons ‚ü¶c‚üß ‚ü¶c‚üßs*)
        (Œª (M œÉ ‚Ñ¨)
          (match-define (-‚Ñ¨ _ œÅ Œì _) ‚Ñ¨)
          (define Mk-D (-W¬π (-Clo xs ‚ü¶d‚üß œÅ Œì) mk-d))
          (((‚Üù.-->i '() ‚ü¶c‚üßs* Mk-D l) ‚ü¶c‚üß) M œÉ ‚Ñ¨))])]
    [(-x/c x)
     (Œª (M œÉ ‚Ñ¨)
       (define Œì (-‚Ñ¨-cnd ‚Ñ¨))
       (define ŒìWs
         (for/set: : (‚Ñò -ŒìW) ([V (œÉ@ œÉ (-Œ±.x/c x))])
           (-ŒìW Œì (-W (list V) e))))
       (values ‚ä•œÉ ŒìWs ‚àÖ ‚àÖ))]
    [(-struct/c si cs l)
     (match cs
       ['()
        (Œª (M œÉ ‚Ñ¨)
          (define V (-St/C #t si '()))
          (define W (-W (list V) e))
          (values ‚ä•œÉ {set (-ŒìW (-‚Ñ¨-cnd ‚Ñ¨) W)} ‚àÖ ‚àÖ))]
       [(cons c cs*)
        ((‚Üù.struct/c si '() (map ‚áì cs*) l) (‚áì c))])]))

(: ‚Ñ∞‚ü¶_‚üß : -‚Ñ∞ (‚Ñò -ŒìW) ‚Üí -‚ü¶e‚üß)
;; Plug answers `ŒìWs` into hole `‚Ñ∞` and resume computation
;; Stacks `‚Ñ∞` are finite, but I can't "compile" them ahead of time because they depend on
;; "run-time" `V`. Using functions instead of flat values to represent `‚Ñ∞` may generate
;; infinitely many equivalent but distinct (Racket-level) functions.
;; Memoization might help, but I doubt it speeds up anything.
;; So I'll keep things simple for now.
(define (‚Ñ∞‚ü¶_‚üß ‚Ñ∞ ŒìWs)
  (let go : -‚ü¶e‚üß ([‚Ñ∞ : -‚Ñ∞ ‚Ñ∞])
    (match ‚Ñ∞
      ;; Hacky forms
      [(-‚Ñ∞‚Çö.modules ‚Ñ∞* ‚ü¶m‚üßs ‚ü¶e‚üß) ((‚Üù.modules ‚ü¶m‚üßs ‚ü¶e‚üß) (go ‚Ñ∞*))]
      [(-‚Ñ∞.def m xs ‚Ñ∞*) ((‚Üù.def m xs) (go ‚Ñ∞*))]
      [(-‚Ñ∞.dec id ‚Ñ∞*) ((‚Üù.dec id) (go ‚Ñ∞*))]
      ;; Regular forms
      ['‚ñ° (Œª _ (values ‚ä•œÉ ŒìWs ‚àÖ ‚àÖ))]
      [(-‚Ñ∞.if ‚Ñ∞* ‚ü¶e‚ÇÅ‚üß ‚ü¶e‚ÇÇ‚üß) ((‚Üù.if ‚ü¶e‚ÇÅ‚üß ‚ü¶e‚ÇÇ‚üß) (go ‚Ñ∞*))]
      [(-‚Ñ∞.@ WVs ‚Ñ∞* ‚ü¶e‚üßs loc) ((‚Üù.@ WVs ‚ü¶e‚üßs loc) (go ‚Ñ∞*))]
      [(-‚Ñ∞.begin ‚Ñ∞* ‚ü¶e‚üßs) ((‚Üù.begin ‚ü¶e‚üßs) (go ‚Ñ∞*))]
      [(-‚Ñ∞.begin0.v ‚Ñ∞* ‚ü¶e‚üßs) ((‚Üù.begin0.v ‚ü¶e‚üßs) (go ‚Ñ∞*))]
      [(-‚Ñ∞.begin0.e W ‚Ñ∞* ‚ü¶e‚üßs) ((‚Üù.begin0.e W ‚ü¶e‚üßs) (go ‚Ñ∞*))]
      [(-‚Ñ∞.let-values xs-Ws (cons xs ‚Ñ∞*) xs-‚ü¶e‚üßs ‚ü¶e‚üß l)
       ((‚Üù.let-values xs-Ws xs xs-‚ü¶e‚üßs ‚ü¶e‚üß l) (go ‚Ñ∞*))]
      [(-‚Ñ∞.letrec-values Œ¥œÅ (cons xs ‚Ñ∞*) xs-‚ü¶e‚üßs ‚ü¶e‚üß l)
       ((‚Üù.letrec-values Œ¥œÅ xs xs-‚ü¶e‚üßs ‚ü¶e‚üß l) (go ‚Ñ∞*))]
      [(-‚Ñ∞.set! x ‚Ñ∞*) ((‚Üù.set! x) (go ‚Ñ∞*))]
      [(-‚Ñ∞.Œº/c x ‚Ñ∞*) ((‚Üù.Œº/c x) (go ‚Ñ∞*))]
      [(-‚Ñ∞.-->i Cs ‚Ñ∞* ‚ü¶c‚üßs ‚ü¶mk-d‚üß l)
       ((‚Üù.-->i Cs ‚ü¶c‚üßs ‚ü¶mk-d‚üß l) (go ‚Ñ∞*))]
      [(-‚Ñ∞.struct/c si Cs ‚Ñ∞* ‚ü¶c‚üßs l)
       ((‚Üù.struct/c si Cs ‚ü¶c‚üßs l) (go ‚Ñ∞*))])))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;; Helpers
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define-syntax-rule (‚äî¬≥ x y)
  (let-values ([(m‚ÇÅ m‚ÇÇ m‚ÇÉ) x]
               [(n‚ÇÅ n‚ÇÇ n‚ÇÉ) y])
    (values (‚äî/m m‚ÇÅ n‚ÇÅ) (‚äî/m m‚ÇÇ n‚ÇÇ) (‚äî/m m‚ÇÉ n‚ÇÉ))))

(: collect : -M -Œû -‚Ñ¨ ‚Üí -ŒîœÉ (‚Ñò -ŒìW) (‚Ñò -ŒìE) (‚Ñò -‚Ñê) ‚Üí (Values -ŒîM -ŒîŒû -ŒîœÉ))
;; Collect evaluation results into store deltas
(define ((collect M Œû ‚Ñ¨) Œ¥œÉ ŒìWs ŒìEs ‚Ñês)
  
  (define Œ¥M : -ŒîM
    (let* ([As (M@ M ‚Ñ¨)]
           [Œ¥-As (-- (‚à™ ŒìWs ŒìEs) As)])
      (if (set-empty? Œ¥-As) ‚ä•M (hash ‚Ñ¨ Œ¥-As))))
  
  (define Œ¥Œû
    (for*/fold ([Œ¥Œû : -ŒîŒû ‚ä•Œû])
               ([‚Ñê ‚Ñês]
                [‚Ñã  (in-value (-‚Ñê-hole ‚Ñê))]
                [‚Ñ¨* (in-value (-‚Ñê-target ‚Ñê))]
                [‚Ñõ  (in-value (-‚Ñõ ‚Ñ¨ ‚Ñã))]
                #:unless (m‚àã Œû ‚Ñ¨* ‚Ñõ))
      (‚äî Œ¥Œû ‚Ñ¨* ‚Ñõ)))
  
  (values Œ¥M Œ¥Œû Œ¥œÉ))

(: ‚áìconst : Base ‚Üí -‚ü¶e‚üß)
(define (‚áìconst b)
  (define W (let ([B (-b b)]) (-W (list B) B)))
  (Œª (M œÉ ‚Ñ¨)
    (values ‚ä•œÉ {set (-ŒìW (-‚Ñ¨-cnd ‚Ñ¨) W)} ‚àÖ ‚àÖ)))

(define ‚ü¶void‚üß (‚áìconst (void)))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;; Testing
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

#;(define (ev‚ÇÅ [e : -e])
  (define-values (Œ¥M Œ¥Œû Œ¥œÉ) (ev ‚ä•M ‚ä•Œû ‚ä•œÉ (-‚Ñ¨ (‚áì e) ‚ä•œÅ)))
  (values (show-M Œ¥M) (show-Œû Œ¥Œû) (show-œÉ Œ¥œÉ)))
