#lang typed/racket/base

(provide ev ev* co co* ‚áì‚Çö ‚áì‚Çò‚Çõ ‚áì‚Çò ‚áì ‚äî¬≥)

(require racket/match
         racket/set
         "../utils/main.rkt"
         "../ast/definition.rkt"
         "../runtime/main.rkt"
         "../proof-relation/main.rkt"
         "helpers.rkt"
         "continuation.rkt")

(: ev* : -M -Œû -œÉ (‚Ñò -œÑ) ‚Üí (Values -ŒîM -ŒîŒû -ŒîœÉ))
(define (ev* M Œû œÉ œÑs)
  (for/fold ([Œ¥M : -ŒîM ‚ä•M] [Œ¥Œû : -ŒîŒû ‚ä•Œû] [Œ¥œÉ : -ŒîœÉ ‚ä•œÉ])
            ([œÑ œÑs])
    (ev M Œû œÉ œÑ)))

(: co* : -M -Œû -œÉ (‚Ñò -Co) ‚Üí (Values -ŒîM -ŒîŒû -ŒîœÉ))
(define (co* M Œû œÉ Cos)
  (for/fold ([Œ¥M : -ŒîM ‚ä•M] [Œ¥Œû : -ŒîŒû ‚ä•Œû] [Œ¥œÉ : -ŒîœÉ ‚ä•œÉ])
            ([Co Cos])
    (co M Œû œÉ Co)))

(: ev : -M -Œû -œÉ -œÑ ‚Üí (Values -ŒîM -ŒîŒû -ŒîœÉ))
;; Execute check-point `œÑ`, which is either function block `‚Ñ¨` for contract checking `‚Ñ≥`
(define (ev M Œû œÉ œÑ)
  (apply/values
   (collect M Œû œÑ)
   (match œÑ
     [(-‚Ñ¨ ‚ü¶e‚üß ‚Ñí) (‚ü¶e‚üß M œÉ ‚Ñí)]
     [(-‚Ñ≥ l¬≥ ‚Ñì W-C W-V ‚Ñí) ((mon l¬≥ ‚Ñì W-C W-V) M œÉ ‚Ñí)])))

(: co : -M -Œû -œÉ -Co ‚Üí (Values -ŒîM -ŒîŒû -ŒîœÉ))
;; Resume computation `‚Ñã[A]`, propagating errors and plugging values into hole.
(define (co M Œû œÉ Co)
  (match-define (-Co (-‚Ñõ œÑ‚ÇÄ ‚Ñã‚ÇÄ) œÑ As) Co)
  (match-define (-‚Ñã ‚Ñí‚ÇÄ f bnds ‚Ñ∞) ‚Ñã‚ÇÄ)
  ;; Note: in general, `‚Ñí‚ÇÄ` can be more "updated" than in `œÑ‚ÇÄ`, because of e.g. `let`

  ;; Propagate errors and plug values into hole
  (define-values (ŒìWs ŒìEs)
    (let ()
      (define-values (xs args) (unzip bnds))
      (define fargs (apply -?@ f args))
      (define Œì‚ÇÄ (-‚Ñí-cnd ‚Ñí‚ÇÄ))

      (for/fold ([ŒìWs : (‚Ñò -ŒìW) ‚àÖ] [ŒìEs : (‚Ñò -ŒìE) ‚àÖ])
                ([A As])
        (match A
          [(-ŒìW Œì (-W Vs s))
           #;(printf "plausible-rt?:~n  Caller: ~a : ~a ~a~n   Callee: ~a : ~a~n"
                   (show-œÑ œÑ‚ÇÄ)
                   (show-s f)
                   (for/list : (Listof Sexp) ([bnd bnds])
                     (match-define (cons x e) bnd)
                     `(,x ‚Ü¶ ,(show-s e)))
                   (show-œÑ œÑ)
                   (show-W (-W Vs s)))
           (cond
             [(plausible-rt? Œì‚ÇÄ f bnds Œì s)
              (define Œì‚ÇÄ* (-Œì-plus-Œ≥ Œì‚ÇÄ (-Œ≥ œÑ f bnds)))
              (values (set-add ŒìWs (-ŒìW Œì‚ÇÄ* (-W Vs (and s fargs)))) ŒìEs)]
             [else (values ŒìWs ŒìEs)])]
          [(-ŒìE Œì (and blm (-blm l+ _ _ _)))
           (cond
             [(plausible-rt? Œì‚ÇÄ f bnds Œì #f)
              (define Œì‚ÇÄ* (-Œì-plus-Œ≥ Œì‚ÇÄ (-Œ≥ œÑ f bnds)))
              (case l+ ; ignore blamings on system, top-level, and havoc
                [(Œõ ‚Ä† havoc) (values ŒìWs ŒìEs)]
                [else (values ŒìWs (set-add ŒìEs (-ŒìE Œì‚ÇÄ* blm)))])]
             [else (values ŒìWs ŒìEs)])]))))
  
  (define-values (Œ¥œÉ* ŒìWs* ŒìEs* ‚Ñês*) ((‚Ñ∞‚ü¶_‚üß ‚Ñ∞ ŒìWs) M œÉ ‚Ñí‚ÇÄ))
  (apply/values (collect M Œû œÑ‚ÇÄ) (values Œ¥œÉ* ŒìWs* (‚à™ ŒìEs ŒìEs*) ‚Ñês*)))

(: ‚áì‚Çö : (Listof -module) -e ‚Üí -‚ü¶e‚üß)
;; Compile list of modules and top-level expression into computation that
;; runs modules and the top level expression and returns top-level expression's result
(define (‚áì‚Çö ms e)
  (define ‚ü¶e‚üß (‚áì '‚Ä† e))
  (match (map ‚áì‚Çò ms)
    ['() ‚ü¶e‚üß]
    [(cons ‚ü¶m‚üß ‚ü¶m‚üßs) ((‚Üù.begin (append ‚ü¶m‚üßs (list ‚ü¶e‚üß))) ‚ü¶m‚üß)]))

(: ‚áì‚Çò‚Çõ : (Listof -module) ‚Üí -‚ü¶e‚üß)
;; Compile list of modules into computation that runs modules and return
;; last module's last expression's result
(define (‚áì‚Çò‚Çõ ms)
  (match (map ‚áì‚Çò ms)
    ['() ‚ü¶void‚üß]
    [(cons ‚ü¶m‚üß ‚ü¶m‚üßs) ((‚Üù.begin ‚ü¶m‚üßs) ‚ü¶m‚üß)]))

(: ‚áì‚Çò : -module ‚Üí -‚ü¶e‚üß)
;; Compile module into computation that runs the module and returns its last expression's result
(define (‚áì‚Çò m)
  (match-define (-module l ds) m)
  
  (: ‚áìpc : -provide-spec ‚Üí -‚ü¶e‚üß)
  (define (‚áìpc spec)
    (match-define (-p/c-item x c ‚Ñì) spec)
    ((‚Üù.dec (-ùíæ x l) ‚Ñì) (‚áì l c)))

  (: ‚áìd : -module-level-form ‚Üí -‚ü¶e‚üß)
  (define (‚áìd d)
    (match d
      [(-define-values xs e)
       (define Œ±s : (Listof -Œ±.def)
         (for/list ([x xs]) (-Œ±.def (-ùíæ x l))))
       ((‚Üù.def l Œ±s) (‚áì l e))]
      [(-provide specs) ((‚Üù.begin (map ‚áìpc specs)) ‚ü¶void‚üß)]
      [(? -e? e) (‚áì l e)]
      [_
       (log-warning "‚áìd: ignore ~a~n" (show-module-level-form d))
       ‚ü¶void‚üß]))

  (match (map ‚áìd ds)
    ['() ‚ü¶void‚üß]
    [(cons ‚ü¶d‚üß ‚ü¶d‚üßs) ((‚Üù.begin ‚ü¶d‚üßs) ‚ü¶d‚üß)]))

(: ‚áì : Mon-Party -e ‚Üí -‚ü¶e‚üß)
;; Compile expresion to computation
(define (‚áì l e)

  (: ‚Üì : -e ‚Üí -‚ü¶e‚üß)
  (define (‚Üì e) (‚áì l e))
  
  (remember-e!
   (match e
     [(-Œª xs e*)
      (define ‚ü¶e*‚üß (‚Üì e*))
      (Œª (M œÉ ‚Ñí)
        (match-define (-‚Ñí œÅ Œì _) ‚Ñí)
        (values ‚ä•œÉ {set (-ŒìW Œì (-W (list (-Clo xs ‚ü¶e*‚üß œÅ Œì)) e))} ‚àÖ ‚àÖ))]
     [(-case-Œª clauses)
      (define ‚ü¶clause‚üßs : (Listof (Pairof (Listof Var-Name) -‚ü¶e‚üß))
        (for/list ([clause clauses])
          (match-define (cons xs e) clause)
          (cons xs (‚Üì e))))
      (Œª (M œÉ ‚Ñí)
        (match-define (-‚Ñí œÅ Œì _) ‚Ñí)
        (values ‚ä•œÉ {set (-ŒìW Œì (-W (list (-Case-Clo ‚ü¶clause‚üßs œÅ Œì)) e))} ‚àÖ ‚àÖ))]
     [(? -prim? p) (‚áì‚Çö·µ£‚Çò p)]
     [(-‚Ä¢ i)
      (define W (-W -‚óè/Vs e))
      (Œª (M œÉ ‚Ñí)
        (values ‚ä•œÉ {set (-ŒìW (-‚Ñí-cnd ‚Ñí) W)} ‚àÖ ‚àÖ))]
     [(-x x) (‚áì‚Çì x)]
     [(and ref (-ref (and ùíæ (-ùíæ x l‚ÇÄ)) ‚Ñì))
      (define V->s : (-V ‚Üí -s)
        (match-lambda
          [(? -o? o) o]
          ;[(-Ar _ (-Œ±.def (-ùíæ o 'Œõ)) _) o]
          ;[(-Ar _ (-Œ±.wrp (-ùíæ o 'Œõ)) _) o]
          [_ #f]))
      (cond
        ;; same-module referencing returns unwrapped version
        [(equal? l‚ÇÄ l)
         (define Œ± (-Œ±.def ùíæ))
         (Œª (M œÉ ‚Ñí)
           (define Œì (-‚Ñí-cnd ‚Ñí))
           (define ŒìWs
             (for/set: : (‚Ñò -ŒìW) ([V (œÉ@ œÉ Œ±)])
               (define s (or (V->s V) ref)) 
               (-ŒìW Œì (-W (list V) s))))
           (values ‚ä•œÉ ŒìWs ‚àÖ ‚àÖ))]
        ;; cross-module referencing returns wrapped version
        ;;  and (hack) supply the negative context
        [else
         (define Œ± (-Œ±.wrp ùíæ))
         (Œª (M œÉ ‚Ñí)
           (define Œì (-‚Ñí-cnd ‚Ñí))
           (define ŒìWs
             (for/set: : (‚Ñò -ŒìW) ([V (œÉ@ œÉ Œ±)])
               (define s (or (V->s V) ref))
               (-ŒìW Œì (-W (list (supply-negative-party l V)) s))))
           (values ‚ä•œÉ ŒìWs ‚àÖ ‚àÖ))])]
     [(-@ f xs ‚Ñì)
      ((‚Üù.@ l ‚Ñì '() (map ‚Üì xs)) (‚Üì f))]
     [(-if e‚ÇÄ e‚ÇÅ e‚ÇÇ)
      ((‚Üù.if l (‚Üì e‚ÇÅ) (‚Üì e‚ÇÇ)) (‚Üì e‚ÇÄ))]
     [(-wcm k v b)
      (error '‚áì "TODO: wcm")]
     [(-begin es)
      (match es
        [(cons e* es*) ((‚Üù.begin (map ‚Üì es*)) (‚Üì e*))]
        ['() ‚ü¶void‚üß])]
     [(-begin0 e‚ÇÄ es)
      ((‚Üù.begin0.v (map ‚Üì es)) (‚Üì e‚ÇÄ))]
     [(-quote q)
      (cond
        [(Base? q)
         (define b (-b q))
         (Œª (M œÉ ‚Ñí)
           (values ‚ä•œÉ {set (-ŒìW (-‚Ñí-cnd ‚Ñí) (-W (list b) b))} ‚àÖ ‚àÖ))]
        [else (error '‚áì "TODO: (quote ~a)" q)])]
     [(-let-values xs-es e)
      (define xs-‚ü¶e‚üßs
        (for/list : (Listof (Pairof (Listof Var-Name) -‚ü¶e‚üß)) ([xs-e xs-es])
          (match-define (cons xs e‚Çì) xs-e)
          (cons xs (‚Üì e‚Çì))))
      (define ‚ü¶e‚üß (‚Üì e))
      (match xs-‚ü¶e‚üßs 
        ['() ‚ü¶e‚üß]
        [(cons (cons xs‚ÇÄ ‚ü¶e‚üß‚ÇÄ) xs-‚ü¶e‚Çì‚üßs*)
         ((‚Üù.let-values l '() xs‚ÇÄ xs-‚ü¶e‚Çì‚üßs* ‚ü¶e‚üß) ‚ü¶e‚üß‚ÇÄ)])]
     [(-letrec-values xs-es e)
      (define xs-‚ü¶e‚üßs
        (for/list : (Listof (Pairof (Listof Var-Name) -‚ü¶e‚üß)) ([xs-e xs-es])
          (match-define (cons xs e‚Çì) xs-e)
          (cons xs (‚Üì e‚Çì))))
      (define ‚ü¶e‚üß (‚Üì e))
      (match xs-‚ü¶e‚üßs
        ['() ‚ü¶e‚üß]
        [(cons (cons xs‚ÇÄ ‚ü¶e‚üß‚ÇÄ) xs-‚ü¶e‚üßs*)
         (Œª (M œÉ ‚Ñí)
           (define ùíû (-‚Ñí-hist ‚Ñí))
           (define-values (Œ¥œÉ Œ¥œÅ)
             (for*/fold ([Œ¥œÉ : -ŒîœÉ ‚ä•œÉ] [Œ¥œÅ : -ŒîœÅ ‚ä•œÅ])
                        ([xs-‚ü¶e‚üß xs-‚ü¶e‚üßs] [x (car xs-‚ü¶e‚üß)])
               (define Œ± (-Œ±.x x ùíû))
               (values (‚äî Œ¥œÉ Œ± 'undefined)
                       (hash-set Œ¥œÅ x Œ±))))
           (define œÉ* (‚äî/m œÉ Œ¥œÉ))
           (((‚Üù.letrec-values l Œ¥œÅ xs‚ÇÄ xs-‚ü¶e‚üßs* ‚ü¶e‚üß) ‚ü¶e‚üß‚ÇÄ) M œÉ* ‚Ñí))])]
     [(-set! x e*) ((‚Üù.set! x) (‚Üì e*))]
     [(-error msg) (blm l 'Œõ '() (list (-b msg)))] ;; HACK
     [(-amb es) (‚Üù.amb (set-map es ‚Üì))]
     [(-Œº/c x c) ((‚Üù.Œº/c l x) (‚Üì c))]
     [(--> cs d ‚Ñì)
      (define ‚ü¶c‚üßs (map ‚Üì cs))
      (define ‚ü¶d‚üß (‚Üì d))
      (match ‚ü¶c‚üßs
        ['() ((‚Üù.-->.rng l '() ‚Ñì) (‚Üì d))]
        [(cons ‚ü¶c‚üß ‚ü¶c‚üßs*) ((‚Üù.-->.dom l '() ‚ü¶c‚üßs* ‚ü¶d‚üß ‚Ñì) ‚ü¶c‚üß)])]
     [(-->i cs (and mk-d (-Œª xs d)) ‚Ñì)
      (define ‚ü¶d‚üß (‚Üì d))
      (match (map ‚Üì cs)
        ['()
         (define c (-?->i '() mk-d))
         (Œª (M œÉ ‚Ñí)
           (match-define (-‚Ñí œÅ Œì _) ‚Ñí)
           (define Mk-D (-W¬π (-Clo xs ‚ü¶d‚üß œÅ Œì) mk-d))
           (mk-=>i ‚Ñí '() Mk-D ‚Ñì))]
        [(cons ‚ü¶c‚üß ‚ü¶c‚üßs*)
         (Œª (M œÉ ‚Ñí)
           (match-define (-‚Ñí œÅ Œì _) ‚Ñí)
           (define Mk-D (-W¬π (-Clo xs ‚ü¶d‚üß œÅ Œì) mk-d))
           (((‚Üù.-->i '() ‚ü¶c‚üßs* Mk-D ‚Ñì) ‚ü¶c‚üß) M œÉ ‚Ñí))])]
     [(-case-> clauses ‚Ñì)
      (define ‚ü¶clause‚üßs : (Listof (Listof -‚ü¶e‚üß))
        (for/list ([clause clauses])
          (match-define (cons cs d) clause)
          `(,@(map ‚Üì cs) ,(‚Üì d))))
      (match ‚ü¶clause‚üßs
        ['()
         (Œª (M œÉ ‚Ñí)
           (values ‚ä•œÉ {set (-ŒìW (-‚Ñí-cnd ‚Ñí) (-W (list (-Case-> '())) e))} ‚àÖ ‚àÖ))]
        [(cons (cons ‚ü¶c‚üß ‚ü¶c‚üßs) ‚ü¶clause‚üßs*)
         ((‚Üù.case-> l ‚Ñì '() '() ‚ü¶c‚üßs ‚ü¶clause‚üßs*) ‚ü¶c‚üß)])]
     [(-x/c x)
      (Œª (M œÉ ‚Ñí)
        (define Œì (-‚Ñí-cnd ‚Ñí))
        (define ŒìWs
          (for/set: : (‚Ñò -ŒìW) ([V (œÉ@ œÉ (-Œ±.x/c x))])
            (-ŒìW Œì (-W (list V) e))))
        (values ‚ä•œÉ ŒìWs ‚àÖ ‚àÖ))]
     [(-struct/c si cs l)
      (match cs
        ['()
         (Œª (M œÉ ‚Ñí)
           (define V (-St/C #t si '()))
           (define W (-W (list V) e))
           (values ‚ä•œÉ {set (-ŒìW (-‚Ñí-cnd ‚Ñí) W)} ‚àÖ ‚àÖ))]
        [(cons c cs*)
         ((‚Üù.struct/c si '() (map ‚Üì cs*) l) (‚Üì c))])])
   e))

(: ‚Ñ∞‚ü¶_‚üß : -‚Ñ∞ (‚Ñò -ŒìW) ‚Üí -‚ü¶e‚üß)
;; Plug answers `ŒìWs` into hole `‚Ñ∞` and resume computation
;; Stacks `‚Ñ∞` are finite, but I can't "compile" them ahead of time because they depend on
;; "run-time" `V`. Using functions instead of flat values to represent `‚Ñ∞` may generate
;; infinitely many equivalent but distinct (Racket-level) functions.
;; Memoization might help, but I doubt it speeds up anything.
;; So I'll keep things simple for now.
(define (‚Ñ∞‚ü¶_‚üß ‚Ñ∞ ŒìWs)
  (let go : -‚ü¶e‚üß ([‚Ñ∞ : -‚Ñ∞ ‚Ñ∞])
    (match ‚Ñ∞
      ;; Hacky forms
      [(-‚Ñ∞.def m xs ‚Ñ∞*) ((‚Üù.def m xs) (go ‚Ñ∞*))]
      [(-‚Ñ∞.dec ùíæ ‚Ñ∞* ‚Ñì) ((‚Üù.dec ùíæ ‚Ñì) (go ‚Ñ∞*))]
      ;; Regular forms
      ['‚ñ° (Œª _ (values ‚ä•œÉ ŒìWs ‚àÖ ‚àÖ))]
      [(-‚Ñ∞.if l ‚Ñ∞* ‚ü¶e‚ÇÅ‚üß ‚ü¶e‚ÇÇ‚üß) ((‚Üù.if l ‚ü¶e‚ÇÅ‚üß ‚ü¶e‚ÇÇ‚üß) (go ‚Ñ∞*))]
      [(-‚Ñ∞.@ l ‚Ñì WVs ‚Ñ∞* ‚ü¶e‚üßs) ((‚Üù.@ l ‚Ñì WVs ‚ü¶e‚üßs) (go ‚Ñ∞*))]
      [(-‚Ñ∞.begin ‚Ñ∞* ‚ü¶e‚üßs) ((‚Üù.begin ‚ü¶e‚üßs) (go ‚Ñ∞*))]
      [(-‚Ñ∞.begin0.v ‚Ñ∞* ‚ü¶e‚üßs) ((‚Üù.begin0.v ‚ü¶e‚üßs) (go ‚Ñ∞*))]
      [(-‚Ñ∞.begin0.e W ‚Ñ∞* ‚ü¶e‚üßs) ((‚Üù.begin0.e W ‚ü¶e‚üßs) (go ‚Ñ∞*))]
      [(-‚Ñ∞.let-values l xs-Ws (cons xs ‚Ñ∞*) xs-‚ü¶e‚üßs ‚ü¶e‚üß)
       ((‚Üù.let-values l xs-Ws xs xs-‚ü¶e‚üßs ‚ü¶e‚üß) (go ‚Ñ∞*))]
      [(-‚Ñ∞.letrec-values l Œ¥œÅ (cons xs ‚Ñ∞*) xs-‚ü¶e‚üßs ‚ü¶e‚üß)
       ((‚Üù.letrec-values l Œ¥œÅ xs xs-‚ü¶e‚üßs ‚ü¶e‚üß) (go ‚Ñ∞*))]
      [(-‚Ñ∞.set! x ‚Ñ∞*) ((‚Üù.set! x) (go ‚Ñ∞*))]
      [(-‚Ñ∞.Œº/c l x ‚Ñ∞*) ((‚Üù.Œº/c l x) (go ‚Ñ∞*))]
      [(-‚Ñ∞.-->i Cs ‚Ñ∞* ‚ü¶c‚üßs ‚ü¶mk-d‚üß l)
       ((‚Üù.-->i Cs ‚ü¶c‚üßs ‚ü¶mk-d‚üß l) (go ‚Ñ∞*))]
      [(-‚Ñ∞.struct/c si Cs ‚Ñ∞* ‚ü¶c‚üßs l)
       ((‚Üù.struct/c si Cs ‚ü¶c‚üßs l) (go ‚Ñ∞*))]
      [(-‚Ñ∞.mon.v l¬≥ ‚Ñì ‚Ñ∞* Val)
       ((‚Üù.mon.v l¬≥ ‚Ñì Val) (go ‚Ñ∞*))]
      [(-‚Ñ∞.mon.c l¬≥ ‚Ñì Ctc ‚Ñ∞*)
       ((‚Üù.mon.c l¬≥ ‚Ñì Ctc) (go ‚Ñ∞*))])))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;; Helpers
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define-syntax-rule (‚äî¬≥ x y)
  (let-values ([(m‚ÇÅ m‚ÇÇ m‚ÇÉ) x]
               [(n‚ÇÅ n‚ÇÇ n‚ÇÉ) y])
    (values (‚äî/m m‚ÇÅ n‚ÇÅ) (‚äî/m m‚ÇÇ n‚ÇÇ) (‚äî/m m‚ÇÉ n‚ÇÉ))))

(: collect : -M -Œû -œÑ ‚Üí -ŒîœÉ (‚Ñò -ŒìW) (‚Ñò -ŒìE) (‚Ñò -‚Ñê) ‚Üí (Values -ŒîM -ŒîŒû -ŒîœÉ))
;; Collect evaluation results into store deltas
(define ((collect M Œû œÑ) Œ¥œÉ ŒìWs ŒìEs ‚Ñês)
  
  (define Œ¥M : -ŒîM
    (let* ([As (M@ M œÑ)]
           [Œ¥-As (-- (‚à™ ŒìWs ŒìEs) As)])
      (if (set-empty? Œ¥-As) ‚ä•M (hash œÑ Œ¥-As))))
  
  (define Œ¥Œû
    (for*/fold ([Œ¥Œû : -ŒîŒû ‚ä•Œû])
               ([‚Ñê ‚Ñês]
                [‚Ñã  (in-value (-‚Ñê-hole ‚Ñê))]
                [œÑ* (in-value (-‚Ñê-target ‚Ñê))]
                [‚Ñõ  (in-value (-‚Ñõ œÑ ‚Ñã))]
                #:unless (m‚àã Œû œÑ* ‚Ñõ))
      (‚äî Œ¥Œû œÑ* ‚Ñõ)))
  
  (values Œ¥M Œ¥Œû Œ¥œÉ))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;; Testing
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (ev‚ÇÅ [e : -e])
  (define-values (Œ¥M Œ¥Œû Œ¥œÉ) (ev ‚ä•M ‚ä•Œû ‚ä•œÉ (-‚Ñ¨ (‚áì 'test e) ‚Ñí‚àÖ)))
  (values (show-M Œ¥M) (show-Œû Œ¥Œû) (show-œÉ Œ¥œÉ)))


