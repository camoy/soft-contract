#lang typed/racket/base

;; Each function `‚Üù._` implements semantics of corresponding continuation frame,
;; returning ‚ü¶e‚üß‚Üí‚ü¶e‚üß.
;; This is factored out because it's used in both compilation `‚áì` and resumption `‚Ñ∞‚ü¶_‚üß`.

(provide (all-defined-out))

(require
 racket/match racket/set racket/list
 "../utils/main.rkt" "../ast/main.rkt" "../runtime/main.rkt" "../proof-relation/main.rkt" "../delta.rkt")

(: ‚Üù.modules : (Listof -‚ü¶e‚üß) -‚ü¶e‚üß ‚Üí -‚ü¶‚Ñ∞‚üß)
(define ((‚Üù.modules ‚ü¶m‚üßs ‚ü¶e‚üß) ‚ü¶e‚üß·µ¢)
  (define ‚ü¶e‚üß·µ£
    (match ‚ü¶m‚üßs
      ['() ‚ü¶e‚üß]
      [(cons ‚ü¶m‚üß ‚ü¶m‚üßs*) ((‚Üù.modules ‚ü¶m‚üßs* ‚ü¶e‚üß) ‚ü¶m‚üß)]))
  
  (Œª (M œÉ ‚Ñ¨)
    (apply/values
     (acc
      œÉ
      (Œª (‚Ñ∞) (-‚Ñ∞‚Çö.modules ‚Ñ∞ ‚ü¶m‚üßs ‚ü¶e‚üß))
      (Œª (œÉ* Œì* W) (‚ü¶e‚üß·µ£ M œÉ* (-‚Ñ¨-with-Œì ‚Ñ¨ Œì*))))
     (‚ü¶e‚üß·µ¢ M œÉ ‚Ñ¨))))


(: ‚Üù.def : Adhoc-Module-Path (Listof Symbol) ‚Üí -‚ü¶‚Ñ∞‚üß)
;; Define top-level `xs` to be values from `‚ü¶e‚üß`
(define (((‚Üù.def l xs) ‚ü¶e‚üß) M œÉ ‚Ñ¨)
  (apply/values
   (acc
    œÉ
    (Œª (‚Ñ∞) (-‚Ñ∞.def l xs ‚Ñ∞))
    (Œª (œÉ* Œì* W)
      (define Vs (-W-Vs W))
      (with-guarded-arity (length xs) (l Œì* Vs)
        (define Œ¥œÉ
          (for/fold ([Œ¥œÉ : -ŒîœÉ ‚ä•œÉ]) ([x xs] [V Vs])
            (define Œ± (-Œ±.def (-ùíæ x l)))
            (‚äî Œ¥œÉ Œ± V)))
        (values Œ¥œÉ {set (-ŒìW Œì* -Void/W)} ‚àÖ ‚àÖ))))
    (‚ü¶e‚üß M œÉ ‚Ñ¨)))

(: ‚Üù.dec : -ùíæ ‚Üí -‚ü¶‚Ñ∞‚üß)
;; Make `‚ü¶c‚üß`. the contract for `ùíæ`.
(define (((‚Üù.dec ùíæ) ‚ü¶c‚üß) M œÉ ‚Ñ¨)
  (apply/values
   (acc
    œÉ
    (Œª (‚Ñ∞) (-‚Ñ∞.dec ùíæ ‚Ñ∞))
    (Œª (œÉ* Œì* W)
      (define Vs (-W-Vs W))
      (define l (-ùíæ-ctx ùíæ))
      (with-guarded-arity 1 (l Œì* Vs)
        (match-define (list C) Vs)
        (define ‚Ñ¨* (-‚Ñ¨-with-Œì ‚Ñ¨ Œì*))
        (for*/ans ([V (œÉ@ œÉ (-Œ±.def ùíæ))])
          (mon (Mon-Info l 'dummy l) M œÉ ‚Ñ¨* C V)))))
   (‚ü¶c‚üß M œÉ ‚Ñ¨)))

(: ‚Üù.if : Mon-Party -‚ü¶e‚üß -‚ü¶e‚üß ‚Üí -‚ü¶‚Ñ∞‚üß)
(define (((‚Üù.if l ‚ü¶e‚ÇÅ‚üß ‚ü¶e‚ÇÇ‚üß) ‚ü¶e‚ÇÄ‚üß) M œÉ ‚Ñ¨)
  (apply/values
   (acc
    œÉ
    (Œª (‚Ñ∞) (-‚Ñ∞.if l ‚Ñ∞ ‚ü¶e‚ÇÅ‚üß ‚ü¶e‚ÇÇ‚üß))
    (Œª (œÉ* Œì* W)
      (match-define (-W Vs s) W)
      (with-guarded-arity 1 (l Œì* Vs)
        (match-define (list V) Vs)
        (define-values (Œì‚ÇÅ Œì‚ÇÇ) (Œì+/-V M œÉ* Œì* V s))
        (‚äî/ans (with-Œì Œì‚ÇÅ (‚ü¶e‚ÇÅ‚üß M œÉ* (-‚Ñ¨-with-Œì ‚Ñ¨ Œì‚ÇÅ)))
               (with-Œì Œì‚ÇÇ (‚ü¶e‚ÇÇ‚üß M œÉ* (-‚Ñ¨-with-Œì ‚Ñ¨ Œì‚ÇÇ)))))))
    (‚ü¶e‚ÇÄ‚üß M œÉ ‚Ñ¨)))

(: ‚Üù.@ : Mon-Party -‚Ñì (Listof -W¬π) (Listof -‚ü¶e‚üß) ‚Üí -‚ü¶‚Ñ∞‚üß)
(define (((‚Üù.@ l ‚Ñì Ws ‚ü¶e‚üßs) ‚ü¶e‚üß) M œÉ ‚Ñ¨)
  (apply/values
   (acc
    œÉ
    (Œª (‚Ñ∞) (-‚Ñ∞.@ l ‚Ñì Ws ‚Ñ∞ ‚ü¶e‚üßs))
    (Œª (œÉ* Œì* W)
      (match-define (-W Vs s) W)
      (with-guarded-arity 1 (l Œì* Vs)
        (match-define (list V) Vs)
        (define Ws* (cons (-W¬π V s) Ws))
        (define ‚Ñ¨* (-‚Ñ¨-with-Œì ‚Ñ¨ Œì*))
        (match ‚ü¶e‚üßs ; TODO: move this dispatch out?
          ['()
           (match-define (cons W‚Çï W‚Çìs) (reverse Ws*))
           (ap l ‚Ñì M œÉ* ‚Ñ¨* W‚Çï W‚Çìs)]
          [(cons ‚ü¶e‚üß* ‚ü¶e‚üßs*)
           (((‚Üù.@ l ‚Ñì Ws* ‚ü¶e‚üßs*) ‚ü¶e‚üß*) M œÉ* ‚Ñ¨*)]))))
   (‚ü¶e‚üß M œÉ ‚Ñ¨)))

(: ‚Üù.begin : (Listof -‚ü¶e‚üß) ‚Üí -‚ü¶‚Ñ∞‚üß)
(define ((‚Üù.begin ‚ü¶e‚üßs) ‚ü¶e‚üß)
  (match ‚ü¶e‚üßs
    ['() ‚ü¶e‚üß]
    [(cons ‚ü¶e‚üß* ‚ü¶e‚üßs*)
     (define ‚ü¶e·µ£‚üß ((‚Üù.begin ‚ü¶e‚üßs*) ‚ü¶e‚üß*))
     (Œª (M œÉ ‚Ñ¨)
       (apply/values
        (acc
         œÉ
         (Œª (‚Ñ∞) (-‚Ñ∞.begin ‚Ñ∞ ‚ü¶e‚üßs))
         (Œª (œÉ* Œì* _) (‚ü¶e·µ£‚üß M œÉ* (-‚Ñ¨-with-Œì ‚Ñ¨ Œì*))))
        (‚ü¶e‚üß M œÉ ‚Ñ¨)))]))

(: ‚Üù.begin0.v : (Listof -‚ü¶e‚üß) ‚Üí -‚ü¶‚Ñ∞‚üß)
;; Waiting on `‚ü¶e‚üß` to be the returned value for `begin0`
(define ((‚Üù.begin0.v ‚ü¶e‚üßs) ‚ü¶e‚üß)
  (match ‚ü¶e‚üßs
    ['() ‚ü¶e‚üß]
    [(cons ‚ü¶e‚üß* ‚ü¶e‚üßs*)
     (Œª (M œÉ ‚Ñ¨)
       (apply/values
        (acc
         œÉ
         (Œª (‚Ñ∞) (-‚Ñ∞.begin0.v ‚Ñ∞ ‚ü¶e‚üßs))
         (Œª (œÉ* Œì* W)
           (define ‚ü¶e·µ£‚üß ((‚Üù.begin0.e W ‚ü¶e‚üßs*) ‚ü¶e‚üß*))
           (‚ü¶e·µ£‚üß M œÉ* (-‚Ñ¨-with-Œì ‚Ñ¨ Œì*))))
        (‚ü¶e‚üß M œÉ ‚Ñ¨)))]))

(: ‚Üù.begin0.e : -W (Listof -‚ü¶e‚üß) ‚Üí -‚ü¶‚Ñ∞‚üß)
(define ((‚Üù.begin0.e W ‚ü¶e‚üßs) ‚ü¶e‚üß)
  (match ‚ü¶e‚üßs
    ['()
     (Œª (M œÉ ‚Ñ¨)
       (values ‚ä•œÉ {set (-ŒìW (-‚Ñ¨-cnd ‚Ñ¨) W)} ‚àÖ ‚àÖ))]
    [(cons ‚ü¶e‚üß* ‚ü¶e‚üßs*)
     (define ‚ü¶e‚üß·µ£ ((‚Üù.begin0.e W ‚ü¶e‚üßs*) ‚ü¶e‚üß*))
     (Œª (M œÉ ‚Ñ¨)
       (apply/values
        (acc
         œÉ
         (Œª (‚Ñ∞) (-‚Ñ∞.begin0.e W ‚Ñ∞ ‚ü¶e‚üßs))
         (Œª (œÉ* Œì* _)
           (‚ü¶e‚üß·µ£ M œÉ* (-‚Ñ¨-with-Œì ‚Ñ¨ Œì*))))
        (‚ü¶e‚üß M œÉ ‚Ñ¨)))]))

(: ‚Üù.let-values : Mon-Party
                  (Listof (Pairof Symbol -W¬π))
                  (Listof Symbol)
                  (Listof (Pairof (Listof Symbol) -‚ü¶e‚üß))
                  -‚ü¶e‚üß
                  ‚Üí -‚ü¶‚Ñ∞‚üß)
(define (((‚Üù.let-values l x-Ws xs xs-‚ü¶e‚üßs ‚ü¶e‚üß) ‚ü¶e‚Çì‚üß) M œÉ ‚Ñ¨)
  (apply/values
   (acc
    œÉ
    (Œª (‚Ñ∞) (-‚Ñ∞.let-values l x-Ws (cons xs ‚Ñ∞) xs-‚ü¶e‚üßs ‚ü¶e‚üß))
    (Œª (œÉ* Œì* W)
      (match-define (-W Vs s) W)
      (define n (length xs))
      (with-guarded-arity n (l Œì* Vs)
        (define x-Ws*
          (foldr
           (Œª ([x : Symbol] [V : -V] [s : -s] [x-Ws* : (Listof (Pairof Symbol -W¬π))])
             (cons (cons x (-W¬π V s)) x-Ws*))
           x-Ws
           xs
           Vs
           (split-values s n)))
        (match xs-‚ü¶e‚üßs ; TODO dispatch outside?
          ['()
           (match-define (-‚Ñ¨ ‚ü¶e‚üß‚ÇÄ œÅ _ ùíû) ‚Ñ¨)
           (define-values (œÅ* Œ¥œÉ Œì**)
             (for/fold ([œÅ* : -œÅ œÅ] [Œ¥œÉ : -ŒîœÉ ‚ä•œÉ] [Œì** : -Œì Œì*])
                       ([x-W x-Ws*])
               (match-define (cons x (-W¬π V s)) x-W)
               (define Œ± (-Œ±.x x ùíû))
               (values (hash-set œÅ* x Œ±)
                       (‚äî Œ¥œÉ Œ± V)
                       (-Œì-with-aliases Œì* x s))))
           (define œÉ** (‚äî/m œÉ* Œ¥œÉ))
           (‚äî/ans (values Œ¥œÉ ‚àÖ ‚àÖ ‚àÖ)
                  (‚ü¶e‚üß M œÉ** (-‚Ñ¨ ‚ü¶e‚üß‚ÇÄ œÅ* Œì** ùíû)))]
          [(cons (cons xs* ‚ü¶e‚üß*) xs-‚ü¶e‚üßs*)
           (((‚Üù.let-values l x-Ws* xs* xs-‚ü¶e‚üßs* ‚ü¶e‚üß) ‚ü¶e‚üß*) M œÉ* (-‚Ñ¨-with-Œì ‚Ñ¨ Œì*))]
          ))))
   (‚ü¶e‚Çì‚üß M œÉ ‚Ñ¨)))

(: ‚Üù.letrec-values : Mon-Party
                     -ŒîœÅ
                     (Listof Symbol)
                     (Listof (Pairof (Listof Symbol) -‚ü¶e‚üß))
                     -‚ü¶e‚üß
                     ‚Üí -‚ü¶‚Ñ∞‚üß)
(define (((‚Üù.letrec-values l Œ¥œÅ xs xs-‚ü¶e‚üßs ‚ü¶e‚üß) ‚ü¶e‚Çì‚üß) M œÉ ‚Ñ¨)
  ;; FIXME: inefficient. `œÅ*` is recomputed many times
  (define œÅ (-‚Ñ¨-env ‚Ñ¨))
  (define ‚Ñ¨* (-‚Ñ¨-with-œÅ ‚Ñ¨ (œÅ++ œÅ Œ¥œÅ)))
  (apply/values
   (acc
    œÉ
    (Œª (‚Ñ∞) (-‚Ñ∞.letrec-values l Œ¥œÅ (cons xs ‚Ñ∞) xs-‚ü¶e‚üßs ‚ü¶e‚üß))
    (Œª (œÉ‚ÇÄ Œì‚ÇÄ W)
      (define n (length xs))
      (match-define (-W Vs s) W)
      (with-guarded-arity n (l Œì‚ÇÄ Vs)
        ;; Update/widen store and path condition
        (define-values (Œ¥œÉ Œì‚ÇÅ)
          (for/fold ([Œ¥œÉ : -ŒîœÉ ‚ä•œÉ] [Œì‚ÇÅ : -Œì Œì‚ÇÄ])
                    ([x xs] [V Vs] [s‚Çì (split-values s n)])
            (values (‚äî Œ¥œÉ (œÅ@ Œ¥œÅ x) V)
                    (Œì+ (if s‚Çì (-Œì-with-aliases Œì‚ÇÅ x s‚Çì) Œì‚ÇÅ) (-?@ 'defined? (-x x))))))
        (define œÉ‚ÇÅ (‚äî/m œÉ‚ÇÄ Œ¥œÉ))
        
        (match xs-‚ü¶e‚üßs
          [(cons (cons xs* ‚ü¶e‚üß*) xs-‚ü¶e‚üßs*)
           (‚äî/ans
             (values Œ¥œÉ ‚àÖ ‚àÖ ‚àÖ)
             (((‚Üù.letrec-values l Œ¥œÅ xs* xs-‚ü¶e‚üßs* ‚ü¶e‚üß) ‚ü¶e‚üß*) M œÉ‚ÇÅ (-‚Ñ¨-with-Œì ‚Ñ¨ Œì‚ÇÅ)))]
          ['()
           (define-values (Œ¥œÉ* ŒìWs ŒìEs ‚Ñês) (‚ü¶e‚üß M œÉ (-‚Ñ¨-with-Œì ‚Ñ¨* Œì‚ÇÅ)))
           
           ;;; Erase irrelevant part of path conditions after executing letrec body

           ;; Free variables that outside of `letrec` understands
           (define xs‚ÇÄ (list->set (hash-keys œÅ)))

           (define ŒìWs*
             (map/set
              (match-lambda
                [(-ŒìW Œì (-W Vs s))
                 (-ŒìW (Œì‚Üì Œì xs‚ÇÄ) (-W Vs (s‚Üì s xs‚ÇÄ)))])
              ŒìWs))
           
           (define ŒìEs*
             (map/set
              (match-lambda
                [(-ŒìE Œì blm)
                 (-ŒìE (Œì‚Üì Œì xs‚ÇÄ) blm)])
              ŒìEs))
           
           (define ‚Ñês*
             (map/set
              (match-lambda
                [(-‚Ñê (-‚Ñã œÅ Œì f bnds ‚Ñ∞) ‚Ñ¨)
                 (define Œì* (Œì‚Üì Œì xs‚ÇÄ))
                 (define f* (s‚Üì f xs‚ÇÄ))
                 (define bnds*
                   (for/list : (Listof (Pairof Symbol -s)) ([bnd bnds])
                     (match-define (cons x s) bnd)
                     (cons x (s‚Üì s xs‚ÇÄ))))
                 (-‚Ñê (-‚Ñã œÅ Œì* f* bnds* ‚Ñ∞) ‚Ñ¨)])
              ‚Ñês))
           
           (values (‚äî/m Œ¥œÉ Œ¥œÉ*) ŒìWs* ŒìEs* ‚Ñês*)]))))
   (‚ü¶e‚Çì‚üß M œÉ ‚Ñ¨*)))

(: ‚Üù.set! : Symbol ‚Üí -‚ü¶‚Ñ∞‚üß)
(define (((‚Üù.set! x) ‚ü¶e‚üß) M œÉ ‚Ñ¨)
  (apply/values
   (acc
    œÉ
    (Œª (‚Ñ∞) (-‚Ñ∞.set! x ‚Ñ∞))
    (Œª (œÉ* Œì* W)
      (match-define (-W Vs s) W)
      (with-guarded-arity 1 ('TODO Œì* Vs)
        (match-define (list V) Vs)
        (define Œ± (œÅ@ (-‚Ñ¨-env ‚Ñ¨) x))
        (values (‚äî ‚ä•œÉ Œ± V) {set (-ŒìW Œì* -Void/W)} ‚àÖ ‚àÖ))))
   (‚ü¶e‚üß M œÉ ‚Ñ¨)))

(: ‚Üù.Œº/c : Mon-Party Integer ‚Üí -‚ü¶‚Ñ∞‚üß)
(define (((‚Üù.Œº/c l x) ‚ü¶c‚üß) M œÉ ‚Ñ¨)
  (apply/values
   (acc
    œÉ
    (Œª (‚Ñ∞) (-‚Ñ∞.Œº/c l x ‚Ñ∞))
    (Œª (œÉ* Œì* W)
      (with-guarded-arity 1 (l Œì* (-W-Vs W))
        (values ‚ä•œÉ {set (-ŒìW Œì* W)} ‚àÖ ‚àÖ))))
   (‚ü¶c‚üß M œÉ ‚Ñ¨)))

(: ‚Üù.-->i : (Listof -W¬π) (Listof -‚ü¶e‚üß) -W¬π Integer ‚Üí -‚ü¶‚Ñ∞‚üß)
(define (((‚Üù.-->i Ws ‚ü¶c‚üßs Mk-D ‚Ñì) ‚ü¶e‚üß) M œÉ ‚Ñ¨)
  (apply/values
   (acc
    œÉ
    (Œª (‚Ñ∞) (-‚Ñ∞.-->i Ws ‚Ñ∞ ‚ü¶c‚üßs Mk-D ‚Ñì))
    (Œª (œÉ* Œì* W)
      (match-define (-W Vs s) W)
      (with-guarded-arity 1 ('TODO Œì* Vs)
        (match-define (list V) Vs)
        (define Ws* (cons (-W¬π V s) Ws))
        (define ‚Ñ¨* (-‚Ñ¨-with-Œì ‚Ñ¨ Œì*))
        (match ‚ü¶c‚üßs
          [(cons ‚ü¶c‚üß ‚ü¶c‚üßs*)
           (((‚Üù.-->i Ws* ‚ü¶c‚üßs* Mk-D ‚Ñì) ‚ü¶c‚üß) M œÉ* ‚Ñ¨*)]
          ['()
           (mk-=>i ‚Ñ¨* Ws* Mk-D ‚Ñì)]))))
   (‚ü¶e‚üß M œÉ ‚Ñ¨)))

(: mk-=>i : -‚Ñ¨ (Listof -W¬π) -W¬π -‚Ñì ‚Üí (Values -ŒîœÉ (‚Ñò -ŒìW) (‚Ñò -ŒìE) (‚Ñò -‚Ñê)))
;; Given *reversed* list of domains and range-maker, create indy contract
(define (mk-=>i ‚Ñ¨ Ws Mk-D ‚Ñì)
  (match-define (-‚Ñ¨ _ _ Œì ùíû) ‚Ñ¨)
  (define-values (Œ¥œÉ Œ±s cs) ; `Œ±s` and `cs` reverses `Ws`, which is reversed
    (for/fold ([Œ¥œÉ : -ŒîœÉ ‚ä•œÉ] [Œ±s : (Listof -Œ±.dom) '()] [cs : (Listof -s) '()])
              ([(W i) (in-indexed Ws)])
      (match-define (-W¬π C c) W)
      (define Œ± (-Œ±.dom ‚Ñì ùíû (assert i exact-nonnegative-integer?)))
      (values (‚äî Œ¥œÉ Œ± C) (cons Œ± Œ±s) (cons c cs))))
  (match-define (-W¬π D d) Mk-D)
  (define C (-=>i Œ±s (assert D -Clo?)))
  (define c (-?->i cs (and d (assert d -Œª?))))
  (values Œ¥œÉ {set (-ŒìW Œì (-W (list C) c))} ‚àÖ ‚àÖ))

(: ‚Üù.havoc : Symbol ‚Üí -‚ü¶e‚üß)
(define ((‚Üù.havoc x) M œÉ ‚Ñ¨)
  (define Vs (œÉ@ œÉ (œÅ@ (-‚Ñ¨-env ‚Ñ¨) x)))
  (error '‚Üù.havoc "TODO"))

(: ‚Üù.struct/c : -struct-info (Listof -W¬π) (Listof -‚ü¶e‚üß) Integer ‚Üí -‚ü¶‚Ñ∞‚üß)
(define (((‚Üù.struct/c si Ws ‚ü¶c‚üßs ‚Ñì) ‚ü¶c‚üß) M œÉ ‚Ñ¨)
  (apply/values
   (acc
    œÉ
    (Œª (‚Ñ∞) (-‚Ñ∞.struct/c si Ws ‚Ñ∞ ‚ü¶c‚üßs ‚Ñì))
    (Œª (œÉ* Œì* W)
      (match-define (-W Vs s) W)
      (with-guarded-arity 1 ('TODO Œì* Vs)
        (match-define (list V) Vs)
        (define Ws* (cons (-W¬π V s) Ws))
        (match ‚ü¶c‚üßs
          [(cons ‚ü¶c‚üß* ‚ü¶c‚üßs*)
           (((‚Üù.struct/c si Ws* ‚ü¶c‚üßs* ‚Ñì) ‚ü¶c‚üß*) M œÉ* (-‚Ñ¨-with-Œì ‚Ñ¨ Œì*))]
          ['()
           (define ùíû (-‚Ñ¨-hist ‚Ñ¨))
           (define-values (Œ¥œÉ Œ±s cs flat?) ; `Œ±s` and `cs` reverse `Ws`, which is reversed
             (for/fold ([Œ¥œÉ : -ŒîœÉ ‚ä•œÉ]
                        [Œ±s : (Listof -Œ±.struct/c) '()]
                        [cs : (Listof -s) '()]
                        [flat? : Boolean #t])
                       ([(W i) (in-indexed Ws*)])
               (match-define (-W¬π C c) W)
               (define Œ± (-Œ±.struct/c ‚Ñì ùíû (assert i exact-nonnegative-integer?)))
               (values (‚äî Œ¥œÉ Œ± C) (cons Œ± Œ±s) (cons c cs) (and flat? (C-flat? C)))))
           (define V (-St/C flat? si Œ±s))
           (values Œ¥œÉ {set (-ŒìW Œì* (-W (list V) (-?struct/c si cs)))} ‚àÖ ‚àÖ)]))))
   (‚ü¶c‚üß M œÉ ‚Ñ¨)))

(: ap : Mon-Party -‚Ñì -M -œÉ -‚Ñ¨ -W¬π (Listof -W¬π) ‚Üí (Values -ŒîœÉ (‚Ñò -ŒìW) (‚Ñò -ŒìE) (‚Ñò -‚Ñê)))
;; Apply value `W‚Çï` to arguments `W‚Çì`s, returning store widening, answers, and suspended computation
(define (ap l ‚Ñì M œÉ ‚Ñ¨‚ÇÄ W‚Çï W‚Çìs)
  (match-define (-‚Ñ¨ ‚ü¶e‚üß‚ÇÄ œÅ‚ÇÄ Œì‚ÇÄ ùíû‚ÇÄ) ‚Ñ¨‚ÇÄ)
  (match-define (-W¬π V‚Çï s‚Çï) W‚Çï)
  (define-values (V‚Çìs s‚Çìs) (unzip-by -W¬π-V -W¬π-s W‚Çìs))
  (define s‚Çê (apply -?@ s‚Çï s‚Çìs))

  ;; TODO: guard against wrong arity

  (: ap/Œ¥ : Symbol ‚Üí (Values -ŒîœÉ (‚Ñò -ŒìW) (‚Ñò -ŒìE) (‚Ñò -‚Ñê)))
  ;; Apply primitive
  (define (ap/Œ¥ o)
    (define-values (Œ¥œÉ A*) (Œ¥ ùíû‚ÇÄ ‚Ñì M œÉ Œì‚ÇÄ o W‚Çìs))
    (cond [(list? A*)
           (values Œ¥œÉ {set (-ŒìW Œì‚ÇÄ (-W A* s‚Çê))} ‚àÖ ‚àÖ)]
          ;; Rely on `Œ¥` giving no error
          [else (‚ä•ans)]))

  (: ap/Œ≤ : -formals -‚ü¶e‚üß -œÅ -Œì ‚Üí (Values -ŒîœÉ (‚Ñò -ŒìW) (‚Ñò -ŒìE) (‚Ñò -‚Ñê)))
  ;; Apply Œª abstraction
  (define (ap/Œ≤ xs ‚ü¶e‚üß œÅ Œì‚ÇÅ)
    (define ùíû‚ÇÅ (ùíû+ ùíû‚ÇÄ (cons ‚ü¶e‚üß ‚Ñì)))
    (define-values (Œ¥œÉ œÅ‚ÇÅ)
      (match xs
        [(? list? xs)
         (for/fold ([Œ¥œÉ : -ŒîœÉ ‚ä•œÉ] [œÅ‚ÇÅ : -œÅ œÅ])
                   ([x xs] [V V‚Çìs])
           (define Œ± (-Œ±.x x ùíû‚ÇÅ))
           (values (‚äî Œ¥œÉ Œ± V) (œÅ+ œÅ‚ÇÅ x Œ±)))]
        [_ (error 'ap/Œ≤ "TODO: varargs")]))
    (define bnds (map (inst cons Symbol -s) xs s‚Çìs))
    (define ‚Ñ¨‚ÇÅ (-‚Ñ¨ ‚ü¶e‚üß œÅ‚ÇÅ Œì‚ÇÅ ùíû‚ÇÅ))
    (values Œ¥œÉ ‚àÖ ‚àÖ {set (-‚Ñê (-‚Ñã œÅ‚ÇÄ Œì‚ÇÄ s‚Çï bnds '‚ñ°) ‚Ñ¨‚ÇÅ)}))
  
  (match V‚Çï
    [(-Clo xs ‚ü¶e‚üß œÅ Œì) (ap/Œ≤ xs ‚ü¶e‚üß œÅ Œì)]
    [(? symbol? o) (ap/Œ¥ o)]
    [(-Ar _ _ l¬≥)
     (error 'ap "Arr")]
    [(-And/C #t Œ±‚ÇÅ Œ±‚ÇÇ)
     (error 'ap "And/C")]
    [(-Or/C #t Œ±‚ÇÅ Œ±‚ÇÇ)
     (error 'ap "Or/C")]
    [(-Not/C Œ±)
     (error 'ap "Not/C")]
    [(-St/C #t si Œ±s)
     (error 'ap "St/C")]
    [(-‚óè) ; FIXME havoc
     (printf "ap: ‚óè~n")
     (values ‚ä•œÉ {set (-ŒìW Œì‚ÇÄ (-W -‚óè/Vs s‚Çê))} ‚àÖ ‚àÖ)]
    [_ (values ‚ä•œÉ ‚àÖ {set (-ŒìE Œì‚ÇÄ (-blm l 'Œõ (list 'procedure?) (list V‚Çï)))} ‚àÖ)]))

(: mon : Mon-Info -M -œÉ -‚Ñ¨ -V -V ‚Üí (Values -ŒîœÉ (‚Ñò -ŒìW) (‚Ñò -ŒìE) (‚Ñò -‚Ñê)))
(define (mon l¬≥ M œÉ ‚Ñ¨ C V)
  (error 'mon "TODO"))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;; Helpers
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(: acc : -œÉ (-‚Ñ∞ ‚Üí -‚Ñ∞) (-œÉ -Œì -W ‚Üí (Values -ŒîœÉ (‚Ñò -ŒìW) (‚Ñò -ŒìE) (‚Ñò -‚Ñê)))
        ‚Üí -ŒîœÉ (‚Ñò -ŒìW) (‚Ñò -ŒìE) (‚Ñò -‚Ñê)
        ‚Üí (Values -ŒîœÉ (‚Ñò -ŒìW) (‚Ñò -ŒìE) (‚Ñò -‚Ñê)))
;; Bind-ish. Takes care of store widening.
;; Caller takes care of stack accumulation and what to do with result.
(define ((acc œÉ f comp) Œ¥œÉ ŒìWs ŒìEs ‚Ñês)
  (define ‚Ñês*
    (map/set
     (match-lambda
       [(-‚Ñê (-‚Ñã œÅ Œì s ùí≥    ‚Ñ∞ ) ‚Ñ¨)
        (-‚Ñê (-‚Ñã œÅ Œì s ùí≥ (f ‚Ñ∞)) ‚Ñ¨)])
     ‚Ñês))
  (define œÉ* (‚äî/m œÉ Œ¥œÉ))
  (for/fold ([Œ¥œÉ : -ŒîœÉ Œ¥œÉ] [ŒìWs* : (‚Ñò -ŒìW) ‚àÖ] [ŒìEs* : (‚Ñò -ŒìE) ŒìEs] [‚Ñês* : (‚Ñò -‚Ñê) ‚Ñês*])
            ([ŒìW ŒìWs])
    (match-define (-ŒìW Œì* W) ŒìW)
    (define-values (Œ¥œÉ+ ŒìWs+ ŒìEs+ ‚Ñês+) (comp œÉ* Œì* W))
    (values (‚äî/m Œ¥œÉ Œ¥œÉ+) (‚à™ ŒìWs* ŒìWs+) (‚à™ ŒìEs* ŒìEs+) (‚à™ ‚Ñês* ‚Ñês+))))

(define-syntax-rule (with-guarded-arity n* (l Œì Vs) e ...)
  (let ([n n*]
        [m (length Vs)])
    (cond
      [(= n m) e ...]
      [else
       (define Cs (make-list n 'any/c))
       (values ‚ä•œÉ ‚àÖ {set (-ŒìE Œì (-blm l 'Œõ Cs Vs))} ‚àÖ)])))
