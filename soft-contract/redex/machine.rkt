#lang racket/base
(require racket/match racket/set racket/list racket/function racket/contract redex
         "lib.rkt" "syntax.rkt" "provability.rkt" "delta.rkt")

(define (‚Üí/œÇ ds)
  (reduction-relation
   L #:domain œÇ

   ;; Bases
   [--> ({b _}   Œì œÉ œÑ Œû M)
        ({b @ b} Œì œÉ œÑ Œû M)
        Base]
   [--> ({(Œª (x) e) œÅ}                 Œì œÉ œÑ Œû M)
        ({(Clo x e œÅ* Œì*) @ (Œª (x) e)} Œì œÉ œÑ Œû M)
        Clo
        (where (œÅ* Œì*) (restrict e œÅ Œì))]
   [--> ({‚Ä¢ _}    Œì œÉ œÑ Œû M)
        ((‚óè @ #f) Œì œÉ œÑ Œû M)
        Opq]
   [--> ({x œÅ}   Œì œÉ œÑ Œû M)
        ({V @ x} Œì œÉ œÑ Œû M)
        Var
        (judgment-holds (‚àà V (lookup œÉ (lookup œÅ x))))
        (where #f (spurious? x V Œì))]
   [--> ({(ref x) _} Œì œÉ œÑ  Œû M)
        ({v ‚ä•}       ‚àÖ œÉ œÑ* Œû* M)
        Ref
        (where {_ ... (def x v) _ ...} ,ds)
        (where œÑ* (v ‚ä• ‚àÖ))
        (where Œû* (MM‚äî Œû [œÑ* ‚Ü¶ ((rt Œì (ref x)) œÑ)]))]

   ;; Pushes
   [--> ({(e_f e_x) œÅ} Œì œÉ œÑ  Œû  M)
        ({e_f       œÅ} Œì œÉ œÑ* Œû* M)
        App-Push
        ;; continue executing with `Œì` b/c i don't wanna drop it,
        ;; but `Œì_f` is enough for the stack address
        (where œÑ* (-œÑ e_f œÅ Œì))
        (where Œû* (MM‚äî Œû [œÑ* ‚Ü¶ ((fn e_x œÅ) œÑ)]))]
   [--> ({(o e_1 e ...) œÅ} Œì œÉ œÑ  Œû  M)
        ({e_1           œÅ} Œì œÉ œÑ* Œû* M)
        Op-Push
        (where œÑ* (-œÑ e_1 œÅ Œì))
        (where Œû* (MM‚äî Œû [œÑ* ‚Ü¶ ((o [] [e ...] œÅ) œÑ)]))]
   [--> ({(if e_0 e_1 e_2) œÅ} Œì œÉ œÑ  Œû  M)
        ({e_0              œÅ} Œì œÉ œÑ* Œû* M)
        If-Push
        (where œÑ* (-œÑ e_0 œÅ Œì))
        (where Œû* (MM‚äî Œû [œÑ* ‚Ü¶ ((if e_1 e_2 œÅ) œÑ)]))]
   [--> ({(set! x e) œÅ} Œì œÉ œÑ  Œû  M)
        ({        e  œÅ} Œì œÉ œÑ* Œû* M)
        Set!-Push
        (where œÑ* (-œÑ e œÅ Œì))
        (where Œû* (MM‚äî Œû [œÑ* ‚Ü¶ ((set! (lookup œÅ x)) œÑ)]))]

   ;; Swaps
   [--> (W       Œì œÉ œÑ  Œû  M )
        ([e_x œÅ] Œì œÉ œÑ* Œû* M*)
        App-Swap
        (judgment-holds (‚àà ((fn e_x œÅ) œÑ**) (lookup Œû œÑ)))
        (where œÑ* (-œÑ e_x œÅ Œì))
        (where Œû* (MM‚äî Œû [œÑ* ‚Ü¶ ((ar W) œÑ**)]))
        (where (e_œÑ _ _) œÑ)
        (where (_ @ ?e) W)
        (where M* (MM‚äî M [e_œÑ ‚Ü¶ (?e Œì)]))]
   [--> (W       Œì œÉ œÑ  Œû  M )
        ({e_i œÅ} Œì œÉ œÑ* Œû* M*)
        Op-Swap
        (judgment-holds (‚àà ((o [W_1 ...] [e_i e ...] œÅ) œÑ**) (lookup Œû œÑ)))
        (where œÑ* (-œÑ e_i œÅ Œì))
        (where Œû* (MM‚äî Œû [œÑ* ‚Ü¶ ((o [W_1 ... W] [e ...] œÅ) œÑ**)]))
        (where (e_œÑ _ _) œÑ)
        (where (_ @ ?e) W)
        (where M* (MM‚äî M [e_œÑ ‚Ü¶ (?e Œì)]))]
   
   ;; (Pop + Return)s
   [--> ({V @ ?e_x} Œì  œÉ  œÑ  Œû  M )
        ({e* œÅ*}    Œì* œÉ* œÑ* Œû* M*)
        App-Œ≤
        (judgment-holds (‚àà ((ar ((Clo x e* œÅ Œì*) @ ?e_f)) œÑ**) (lookup Œû œÑ)))
        (where Œ± (-Œ±.bind x ?e_x Œì))
        (where œÉ* (MM‚äî œÉ [Œ± ‚Ü¶ V]))
        (where œÅ* (++ œÅ [x ‚Ü¶ Œ±]))
        (where œÑ* (-œÑ e* œÅ* Œì*))
        (where Œû* (MM‚äî Œû [œÑ* ‚Ü¶ ((rt Œì (@* ?e_f ?e_x)) œÑ**)]))
        (where (e_œÑ _ _) œÑ)
        (where M* (MM‚äî M [e_œÑ ‚Ü¶ (?e_x Œì)]))]
   [--> ((name W (_ @ ?e)) Œì   œÉ   œÑ  Œû M )
        ({V @ ?e_a}        Œì_a œÉ_a œÑ* Œû M*)
        Op-Pop
        (judgment-holds (‚àà ((o [W_1 ...] [] _) œÑ*) (lookup Œû œÑ)))
        (judgment-holds (Œ¥ œÉ Œì o [W_1 ... W] œÉ_a Œì_a V))
        (where ((_ @ ?e*) ...) (W_1 ... W))
        (where ?e_a (o* o ?e* ...))
        (where #f (spurious? ?e_a V Œì_a))
        (where (e_œÑ _ _) œÑ)
        (where M* (MM‚äî M [e_œÑ ‚Ü¶ (?e Œì)]))]
   [--> ((name W (_ @ ?e)) Œì   œÉ   œÑ  Œû M )
        (err               Œì_a œÉ_a œÑ* Œû M*)
        Op-Err
        (judgment-holds (‚àà ((o [W_1 ...] [] _) œÑ*) (lookup Œû œÑ)))
        (judgment-holds (Œ¥ œÉ Œì o [W_1 ... W] œÉ_a Œì_a err))
        (where ((_ @ ?e*) ...) (W_1 ... W))
        (where (e_œÑ _ _) œÑ)
        (where M* (MM‚äî M [e_œÑ ‚Ü¶ (?e Œì)]))]
   [--> ((name W (_ @ ?e)) Œì  œÉ œÑ  Œû  M )
        ({e* œÅ}            Œì* œÉ œÑ* Œû* M*)
        If-True
        (judgment-holds (‚àà ((if e* _ œÅ) œÑ**) (lookup Œû œÑ)))
        (judgment-holds (split Œì W #t Œì*))
        (where (e_œÑ _ _) œÑ)
        (where M* (MM‚äî M [e_œÑ ‚Ü¶ (?e Œì)]))
        (where œÑ* (-œÑ e* œÅ Œì*))
        (where Œû* (MM‚äî Œû [œÑ* ‚Ü¶ (tail œÑ**)]))]
   [--> ((name W (_ @ ?e)) Œì  œÉ œÑ  Œû  M )
        ({e* œÅ}            Œì* œÉ œÑ* Œû* M*)
        If-False
        (judgment-holds (‚àà ((if _ e* œÅ) œÑ**) (lookup Œû œÑ)))
        (judgment-holds (split Œì W #f Œì*))
        (where (e_œÑ _ _) œÑ)
        (where M* (MM‚äî M [e_œÑ ‚Ü¶ (?e Œì)]))
        (where œÑ* (-œÑ e* œÅ Œì*))
        (where Œû* (MM‚äî Œû [œÑ* ‚Ü¶ (tail œÑ**)]))]
   [--> ((name W {V @ ?e  }) Œì   œÉ œÑ  Œû M )
        (        {V @ ?e_0}  Œì_0 œÉ œÑ* Œû M*)
        Rt
        (judgment-holds (‚àà ((rt Œì_0 ?e_0) œÑ*) (lookup Œû œÑ)))
        (where #f (spurious? ?e_0 V Œì_0))
        (where (e_œÑ _ _) œÑ)
        (where M* (MM‚äî M [e_œÑ ‚Ü¶ (?e Œì)]))]
   [--> ((name W {V @ ?e}) Œì œÉ  œÑ  Œû M )
        (        {1 @ #f}  Œì œÉ* œÑ* Œû M*)
        Set!-Pop
        (judgment-holds (‚àà ((set! Œ±) œÑ*) (lookup Œû œÑ)))
        (where œÉ* (MM‚äî œÉ [Œ± ‚Ü¶ V]))
        (where (e_œÑ _ _) œÑ)
        (where M* (MM‚äî M [e_œÑ ‚Ü¶ (?e Œì)]))]
   [--> ((name W (_ @ ?e)) Œì œÉ œÑ  Œû M )
        (      W           Œì œÉ œÑ* Œû M*)
        Tail
        (judgment-holds (‚àà (tail œÑ*) (lookup Œû œÑ)))
        (where (e_œÑ _ _) œÑ)
        (where M* (MM‚äî M [e_œÑ ‚Ü¶ (?e Œì)]))]

   ;; Hack
   [--> ((name W (V @ ?e)) Œì œÉ œÑ  Œû M )
        ((V @ #f)          ‚àÖ œÉ #f Œû M*)
        Halt
        (side-condition (set-empty? (term (lookup Œû œÑ))))
        (where (e_œÑ _ _) œÑ)
        (where M* (MM‚äî M [e_œÑ ‚Ü¶ (?e Œì)]))]
   [--> (err Œì œÉ œÑ  Œû M )
        (err ‚àÖ œÉ #f Œû M*)
        Halt-Err
        (where (e_œÑ _ _) œÑ)
        (where M* (MM‚äî M [e_œÑ ‚Ü¶ (err Œì)]))]))

(define (‚Üí/Œæ ds)
  (define ‚Üí (‚Üí/œÇ ds))
  (reduction-relation
   L #:domain Œæ
   [--> (Cs  œÉ  Œû  M )
        (Cs* œÉ* Œû* M*)
        (where œÇs
               ,(for/fold ([œÇs {set}]) ([C (in-set (term Cs))])
                  (match-define `(,E ,Œì ,œÑ) C)
                  (set-union œÇs (list->set (apply-reduction-relation ‚Üí (term (,E ,Œì œÉ ,œÑ Œû M)))))))
        (where (Cs* œÉ* Œû* M*)
               ,(let ()
                  (define-values (Cs* œÉ* Œû* M*)
                    (for/fold ([Cs* (term Cs)] [œÉ* (term œÉ)] [Œû* (term Œû)] [M* (term M)])
                              ([œÇ (in-set (term œÇs))])
                      (match-define `(,E ,Œì ,œÉ ,œÑ ,Œû ,M) œÇ)
                      (values (set-add Cs* (term (,E ,Œì ,œÑ)))
                              (term (‚äî ,œÉ* ,œÉ))
                              (term (‚äî ,Œû* ,Œû))
                              (term (‚äî ,M* ,M)))))
                  (list Cs* œÉ* Œû* M*)))
        ;; need this condition for `apply-reduction-relation*` to give something
        (side-condition (not (and (equal? (term Cs) (term Cs*))
                                  (equal? (term œÉ ) (term œÉ* ))
                                  (equal? (term Œû ) (term Œû* ))
                                  (equal? (term M ) (term M* )))))]))

;; Restrict environments before making stack address
(define-metafunction L
  -œÑ : e œÅ Œì -> œÑ
  ;; treat `(ref x)` and `(e e)` specially due to implicit `(rt _)`
  [(-œÑ (ref x) œÅ Œì) ((ref x) ‚ä• Œì)]
  [(-œÑ (e_1 e_2) œÅ Œì) ((e_1 e_2) œÅ* Œì)
   (where (œÅ* _) (restrict (e_1 e_2) œÅ Œì))]
  [(-œÑ e œÅ Œì) (e œÅ* Œì*)
   (where (œÅ* Œì*) (restrict e œÅ Œì))])

(define-metafunction L
  -Œ±.bind : x ?e Œì -> Œ±
  [(-Œ±.bind x #f _) x]
  [(-Œ±.bind x e Œì) (x e Œì*)
   (where (_ Œì*) (restrict e ‚ä• Œì))])

;; inject program to initial state
(define-metafunction L
  ùë∞/œÇ : e -> œÇ
  [(ùë∞/œÇ e)
   ([e ‚ä•] ‚àÖ ‚ä• œÑ {M+ [œÑ ‚Ü¶ ‚àÖ]} ‚ä•)
   (where œÑ (e ‚ä• ‚àÖ))])
(define-metafunction L
  ùë∞/Œæ : e -> Œæ
  [(ùë∞/Œæ e)
   ({S+ ((e ‚ä•) ‚àÖ œÑ)} ‚ä• {M+ [œÑ ‚Ü¶ ‚àÖ]} ‚ä•)
   (where œÑ (e ‚ä• ‚àÖ))])

(define-syntax-rule (pviz/œÇ p)
  (match-let ([`(,ds (... ...) ,e) (term p)])
    (traces (‚Üí/œÇ ds) (term (ùë∞/œÇ ,e)))))
(define-syntax-rule (pviz/Œæ p)
  (match-let ([`(,ds (... ...) ,e) (term p)])
    (traces (‚Üí/Œæ ds) (term (ùë∞/Œæ ,e)))))
(define-syntax-rule (pev/œÇ p)
  (match-let ([`(,ds (... ...) ,e) (term p)])
    (list->set (apply-reduction-relation* (‚Üí/œÇ ds) (term (ùë∞/œÇ ,e)) #:cache-all? #t))))
(define-syntax-rule (pev/Œæ p)
  (match-let ([`(,ds (... ...) ,e) (term p)])
    (match-define `{(,Cs ,œÉ ,Œû ,M)}
      (apply-reduction-relation* (‚Üí/Œæ ds) (term (ùë∞/Œæ ,e)) #:cache-all? #t))
    (values Cs œÉ Œû M)))
(define-syntax-rule (viz/œÇ e) (pviz/œÇ (e)))
(define-syntax-rule (viz/Œæ e) (pviz/Œæ (e)))
(define-syntax-rule (ev/œÇ e) (pev/œÇ (e)))
(define-syntax-rule (ev/Œæ e) (pev/Œæ (e)))

(define-syntax-rule (optimize p)
  (let ()
    (match-define `(,ds (... ...) ,e) (term p)) ; duplicate use of `p`. Be careful.
    (define-values (Cs œÉ Œû M) (pev/Œæ p))
    (append (for/list ([d (in-list ds)])
              (term (opt-d ,M ,d)))
            (list (term (opt-e ,M ,e))))))

(define-metafunction L
  opt-d : M d -> d
  [(opt-d M (def x v_c v)) (def x (opt-e M v_c) (opt-e M v))])
; TODO: opt-e

(define-term t‚ÇÅ (add1 (add1 2)))
(define-term t‚ÇÇ ((Œª (x) (add1 x)) 42))
(define-term t‚ÇÉ (LET* ([f (Œª (x) (cons? x))] [v ‚Ä¢]) (if (f v) (car v) 42)))
(define-term t‚ÇÑ (LET* ([id (Œª (x) x)]
                       [y (id 1)]
                       [z (id 0)])
                  z))
(define-term p‚ÇÅ
  ((def inc (Œª (n) (add1 n)))
   (def opq ‚Ä¢)
   ((ref inc) (ref opq))))
(define-term p‚ÇÇ
  ((def f (Œª (x) ((Œª (n) (add1 1)) x)))
   (def x ‚Ä¢)
   (f x)))
(define-term p‚ÇÉ
  ((def list?
     (Œª (x)
       (if (not x) 1
           (AND (cons? x) ((ref list?) (cdr x))))))
   #;(def rev
     (Œª (l)
       (Œª (ac)
         (if (not l) ac
             (((ref rev) (cdr l)) (cons (car l) ac))))))
   (def opq ‚Ä¢)
   ((ref list?) (ref opq))
   #;(if ((ref list?) (ref opq))
       (((ref rev  ) (ref opq)) 0)
       42)))
(define-term p‚ÇÑ
  ((def f (Œª (n) (if n (set! n 42) 43)))
   (def opq ‚Ä¢)
   ((ref f) (ref opq))))
(define-term ex14
  ((def f
     (Œª (input)
       (Œª (extra)
         (COND
          [(AND (integer? input) (cons? extra) (integer? (car extra)))
           41]
          #:else 42))))
   (def input ‚Ä¢)
   (def extra ‚Ä¢)
   (((ref f) (ref input)) (ref extra))))

(define/contract (debug p)
  (prog? . -> . (values Œæ? (integer? Œæ? . -> . Œæ?) Cs? œÉ? Œû? M? Cs?))
  (match-define (list ds ... e) p)
  (define Œæ‚ÇÄ (term (ùë∞/Œæ ,e)))
  (define r (‚Üí/Œæ ds))
  (define (‚ÜíŒæ Œæ)
    (car (apply-reduction-relation r Œæ)))
  (define (‚Üí n Œæ)
    (cond [(zero? n) Œæ]
          [else (‚Üí (- n 1) (‚ÜíŒæ Œæ))]))
  (match-define (list (list Cs œÉ Œû M)) (apply-reduction-relation* r Œæ‚ÇÄ #:cache-all? #t))
  (values Œæ‚ÇÄ ‚Üí Cs œÉ Œû M
          (for/set ([C Cs] #:unless (third C)) C)))

