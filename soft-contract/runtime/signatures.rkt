#lang typed/racket/base

(provide (all-defined-out))

(require racket/match
         racket/set
         syntax/parse/define
         typed/racket/unit
         bnf
         intern
         set-extras
         "../ast/signatures.rkt"
         )

(define-type -œÅ (Immutable-HashTable Symbol ‚ü™Œ±‚ü´))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;; Stores
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define-type -œÉ (Immutable-HashTable ‚ü™Œ±‚ü´ (‚Ñò -V)))
(define-type -œÉ‚Çñ (Immutable-HashTable -Œ±‚Çñ (‚Ñò -Œ∫)))
(define-type -ùíú (Immutable-HashTable ‚ü™Œ±‚ü´ (‚Ñò -loc)))
(define-type -Œû (Immutable-HashTable -Œ±‚Çñ:ctx (‚Ñò -Œ±‚Çñ:pth)))

(struct -Œ∫ ([rest : -‚ü¶k‚üß]) #:transparent)
(struct -Œ∫.rt -Œ∫ ([dom : (‚Ñò (U Symbol ‚Ñì))] [pc : -Œì] [ans : -?t] [looped? : Boolean] [bnds : (Immutable-HashTable Symbol -t)]) #:transparent)

;; Grouped mutable references to stores
(struct -Œ£ ([œÉ : -œÉ] [œÉ‚Çñ : -œÉ‚Çñ] [ùíú : -ùíú] [Œû : -Œû]) #:mutable #:transparent)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;; Runtime Values
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(-V . ::= . -prim
            (-‚óè (‚Ñò -h))
            (-St -ùíæ (Listof ‚ü™Œ±‚ü´))
            (-Vector (Listof ‚ü™Œ±‚ü´))
            (-Vector^ [content : ‚ü™Œ±‚ü´] [length : #|restricted|# -V])
            (-Hash^ [key : ‚ü™Œ±‚ü´] [val : ‚ü™Œ±‚ü´] [immutable? : Boolean])
            (-Set^ [elems : ‚ü™Œ±‚ü´] [immutable? : Boolean])
            -Fn
            
            ;; Proxied higher-order values
            ;; Inlining the contract in the data definition is ok
            ;; because there's no recursion
            (-Ar [guard : -=>_] [v : ‚ü™Œ±‚ü´] [ctx : -ctx])
            (-St* [guard : -St/C] [val : ‚ü™Œ±‚ü´] [ctx : -ctx])
            (-Vector/guard [guard : (U -Vector/C -Vectorof)] [val : ‚ü™Œ±‚ü´] [ctx : -ctx])
            (-Hash/guard [guard : -Hash/C] [val : ‚ü™Œ±‚ü´] [ctx : -ctx])
            (-Set/guard [guard : -Set/C] [val : ‚ü™Œ±‚ü´] [ctx : -ctx])
            (-Sealed ‚ü™Œ±‚ü´)
            
            -C)

(-Fn . ::= . (-Clo -formals -‚ü¶e‚üß -œÅ -Œì)
             (-Case-Clo [cases : (Listof -Clo)])
             (-Fn‚óè [arity : Arity] [tag : HV-Tag]))

;; Contract combinators
(-C . ::= . (-And/C [flat? : Boolean]
                    [l : -‚ü™Œ±‚ü´‚Ñì]
                    [r : -‚ü™Œ±‚ü´‚Ñì])
            (-Or/C [flat? : Boolean]
                   [l : -‚ü™Œ±‚ü´‚Ñì]
                   [r : -‚ü™Œ±‚ü´‚Ñì])
            (-Not/C -‚ü™Œ±‚ü´‚Ñì)
            (-One-Of/C (Setof Base))
            (-x/C [c : ‚ü™Œ±‚ü´])
            ;; Guards for higher-order values
            -=>_
            (-St/C [flat? : Boolean]
                   [id : -ùíæ]
                   [fields : (Listof -‚ü™Œ±‚ü´‚Ñì)])
            (-Vectorof -‚ü™Œ±‚ü´‚Ñì)
            (-Vector/C (Listof -‚ü™Œ±‚ü´‚Ñì))
            (-Hash/C [key : -‚ü™Œ±‚ü´‚Ñì] [val : -‚ü™Œ±‚ü´‚Ñì])
            (-Set/C [elems : -‚ü™Œ±‚ü´‚Ñì])
            ;; Seal
            (-Seal/C Symbol -H -l)

            ;;
            ->/c -‚â•/c -</c -‚â§/c -‚â¢/c
            )

;; Function contracts
(-=>_ . ::= . (-=>  [doms : (-maybe-var -‚ü™Œ±‚ü´‚Ñì)] [rng : (U (Listof -‚ü™Œ±‚ü´‚Ñì) 'any)])
              (-=>i [doms : (Listof -‚ü™Œ±‚ü´‚Ñì)]
                    [mk-rng : (List -Clo -Œª ‚Ñì)])
              (-‚àÄ/C (Listof Symbol) -‚ü¶e‚üß -œÅ)
              (-Case-> (Listof -=>)))

(struct -blm ([violator : -l]
              [origin : -l]
              [c : (Listof (U -V -v -h))]
              [v : (Listof -V)]
              [loc : ‚Ñì]) #:transparent)
(struct -W¬π ([V : -V] [t : -?t]) #:transparent)
(struct -W ([Vs : (Listof -V)] [t : -?t]) #:transparent)
(-A . ::= . -W -blm)

(struct -‚ü™Œ±‚ü´‚Ñì ([addr : ‚ü™Œ±‚ü´] [loc : ‚Ñì]) #:transparent)
(HV-Tag . ::= . '‚Ä† [#:reuse (Pairof -l -H)])

;; Convenient patterns
(define-match-expander -Cons
  (syntax-rules () [(_ Œ±‚Çï Œ±‚Çú) (-St (== -ùíæ-cons) (list Œ±‚Çï Œ±‚Çú))])
  (syntax-rules () [(_ Œ±‚Çï Œ±‚Çú) (-St -ùíæ-cons      (list Œ±‚Çï Œ±‚Çú))]))
(define-match-expander -Cons*
  (syntax-rules () [(_ Œ±) (-St* (-St/C _ (== -ùíæ-cons) _) Œ± _)]))
(define-match-expander -Box
  (syntax-rules () [(_ Œ±) (-St (== -ùíæ-box) (list Œ±))])
  (syntax-rules () [(_ Œ±) (-St -ùíæ-box      (list Œ±))]))
(define-match-expander -Box*
  (syntax-rules () [(_ Œ±) (-St* (-St/C _ (== -ùíæ-box) _) Œ± _)]))

(define-syntax-rule (blm/simp l+ lo C V ‚Ñì) (-blm l+ lo C V (strip-‚Ñì ‚Ñì)))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;; Monitoring contexts
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(struct -ctx ([pos : -l] [neg : -l] [src : -l] [loc : ‚Ñì]) #:transparent)

(define ctx-neg : (-ctx ‚Üí -ctx)
  (match-lambda
    [(-ctx l+ l- lo ‚Ñì)
     (-ctx l- l+ lo ‚Ñì)]))
(define ctx-with-‚Ñì : (-ctx ‚Ñì ‚Üí -ctx)
  (match-lambda**
   [((-ctx l+ l- lo _) ‚Ñì) (-ctx l+ l- lo ‚Ñì)]))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;; Symbols and Path Conditions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(-loc . ::= . ;; references
              Symbol -ùíæ
              ;; struct field or vector access with concrete offset
              (-loc.offset (U -ùíæ Symbol) Index -t)
              )

(define-type -$ (Immutable-HashTable -loc -t))
(define-type -Œ¥$ (Immutable-HashTable -loc -?t))

;; Path condition is set of terms known to have evaluated to non-#f
;; It also maintains a "canonicalized" symbolic name for each variable
(define-type -Œì (‚Ñò -t))

;; First order term for use in path-condition
(-t . ::= . (-t.x Symbol)
            -ùíæ
            -v
            ‚Ñì ; RHS
            (-t.@ -h (Listof -t)))
;; Formula "head" is either a primitive operation or a stack address
(-h . ::= . -t ; TODO restrict
            ;; Hacky stuff
            -One-Of/C
            (-st/c.mk -ùíæ)
            (-st/c.ac -ùíæ Index)
            (-->i.mk)
            (-->i.dom Index)
            (-->i.rng)
            (-->.mk)
            (-->*.mk)
            (-->.dom Index)
            (-->.rst)
            (-->.rng)
            (-ar.mk)
            (-ar.ctc)
            (-ar.fun)
            (-values.ac Index)
            (-‚â•/c Base)
            (-‚â§/c Base)
            (->/c Base)
            (-</c Base)
            (-‚â¢/c Base)
            (-not/c -o)
            (-clo -‚ü¶e‚üß))
(-?t . ::= . -t #f)

(-special-bin-o . ::= . '> '< '>= '<= '= 'equal? 'eqv? 'eq? #|made up|# '‚â¢)

;; convenient syntax
(define-match-expander -t.not
  (syntax-rules () [(_ t) (-t.@ 'not (list t))])
  (syntax-rules () [(_ t) (and t (-t.@ 'not (list t)))]))

(define-simple-macro (with-Œì+/- ([(Œì‚ÇÅ:id Œì‚ÇÇ:id) e])
                       #:true  e‚ÇÅ
                       #:false e‚ÇÇ)
  (let-values ([(Œì‚ÇÅ Œì‚ÇÇ) e])
    (‚à™ (if Œì‚ÇÅ e‚ÇÅ ‚àÖ)
       (if Œì‚ÇÇ e‚ÇÇ ‚àÖ))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;; Call history
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define-type -‚åäœÅ‚åã (Immutable-HashTable Symbol (Listof ‚Ñì)))
(define-type -edge.tgt (U (Pairof -‚ü¶e‚üß -‚åäœÅ‚åã) -o -?t -h ‚Ñì (-maybe-var ‚Ñì) (Listof -edge.tgt) (‚Ñò Base)))
(struct -edge ([tgt : -edge.tgt] [src : ‚Ñì]) #:transparent)
(define-type -‚Ñã (Listof -edge))
(define-interner -H -‚Ñã
  #:intern-function-name -‚Ñã->-H
  #:unintern-function-name -H->-‚Ñã)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;; Value address
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Some address values have `e` embeded in them.
;; This used to be a neccessary precision hack.
;; Nowaways it's just a temporary fix for the inaccurate source location returned
;; by `fake-contract`
(-Œ± . ::= . ; For wrapped top-level definition
            (-Œ±.wrp -ùíæ)
            ; for binding
            (-Œ±.x Symbol -H (‚Ñò -h))
            (-Œ±.fv -H)
            ; for struct field
            (-Œ±.fld [id : -ùíæ] [loc : ‚Ñì] [ctx : -H] [idx : Index])
            ; for Cons/varargs
            ; idx prevents infinite list
            (-Œ±.var-car [loc : ‚Ñì] [ctx : -H] [idx : (Option Natural)])
            (-Œ±.var-cdr [loc : ‚Ñì] [ctx : -H] [idx : (Option Natural)])

            ;; for wrapped mutable struct
            (-Œ±.st [id : -ùíæ] [mon-ctx : -ctx] [ctx : -H])

            ;; for vector indices
            (-Œ±.idx [loc : ‚Ñì] [ctx : -H] [idx : Natural])
            
            ;; for vector^ content
            (-Œ±.vct [loc : ‚Ñì] [ctx : -H])

            ;; for hash^ content
            (-Œ±.hash.key [loc : ‚Ñì] [ctx : -H])
            (-Œ±.hash.val [loc : ‚Ñì] [ctx : -H])

            ;; for set^ content
            (-Œ±.set.elem [loc : ‚Ñì] [ctx : -H])

            ;; for wrapped vector
            (-Œ±.unvct [mon-ctx : -ctx] [ctx : -H])

            ;; for wrapped hash
            (-Œ±.unhsh [mon-ctx : -ctx] [ctx : -H])

            ;; for wrapped set
            (-Œ±.unset [mon-ctx : -ctx] [ctx : -H])

            ;; for contract components
            (-Œ±.and/c-l [loc : ‚Ñì] [ctx : -H])
            (-Œ±.and/c-r [loc : ‚Ñì] [ctx : -H])
            (-Œ±.or/c-l [loc : ‚Ñì] [ctx : -H])
            (-Œ±.or/c-r [loc : ‚Ñì] [ctx : -H])
            (-Œ±.not/c [loc : ‚Ñì] [ctx : -H])
            (-Œ±.x/c Symbol -H)
            (-Œ±.vector/c [loc : ‚Ñì] [ctx : -H] [idx : Natural])
            (-Œ±.vectorof [loc : ‚Ñì] [ctx : -H])
            (-Œ±.hash/c-key [loc : ‚Ñì] [ctx : -H])
            (-Œ±.hash/c-val [loc : ‚Ñì] [ctx : -H])
            (-Œ±.set/c-elem [loc : ‚Ñì] [ctx : -H])
            (-Œ±.struct/c [id : -ùíæ] [loc : ‚Ñì] [ctx : -H] [idx : Natural])
            (-Œ±.dom [loc : ‚Ñì] [ctx : -H] [idx : Natural])
            (-Œ±.rst [loc : ‚Ñì] [ctd : -H])
            (-Œ±.rng [loc : ‚Ñì] [ctx : -H] [idx : Natural])

            ;; for wrapped function
            (-Œ±.fn [sym : (Option -‚ü¶e‚üß)] [mon-ctx : -ctx] [ctx : -H] [pc : -Œì])

            ;; For values wrapped in seals
            (-Œ±.sealed Symbol -H) ; points to wrapped objects

            ;; HACK
            (-Œ±.hv [tag : HV-Tag])
            (-Œ±.mon-x/c Symbol -H -l)
            (-Œ±.fc-x/c Symbol -H)
            -ùíæ
            ;; tmp hack.
            ;; Only use this in the prim DSL where all values are finite
            ;; with purely syntactic components
            (-Œ±.imm -V)
            ;; indirection for `listof` to keep in-sync with regular listof contracts
            (-Œ±.imm-listof Symbol #|elem, ok with care|# -V ‚Ñì)
            (-Œ±.imm-ref-listof Symbol #|elem, ok with care|# -V ‚Ñì)

            ;; Escaped fields
            (-Œ±.escaped -ùíæ Integer)
            )

(-Œ±.rec-ref . ::= . -Œ±.x/c -Œ±.imm-listof)

(define-interner ‚ü™Œ±‚ü´ -Œ±
  #:intern-function-name -Œ±->‚ü™Œ±‚ü´
  #:unintern-function-name ‚ü™Œ±‚ü´->-Œ±)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;; Compiled expression
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; A computation returns set of next states
;; and may perform side effects widening mutable store(s)
(define-type -‚ü¶e‚üß (-œÅ -$ -Œì -H -Œ£ -‚ü¶k‚üß ‚Üí (‚Ñò -œÇ)))
(define-type -‚ü¶k‚üß (-A -$ -Œì -H -Œ£     ‚Üí (‚Ñò -œÇ)))
(define-type -‚ü¶f‚üß (‚Ñì (Listof -W¬π) -$ -Œì -H -Œ£ -‚ü¶k‚üß ‚Üí (‚Ñò -œÇ)))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;; State
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Configuration
(struct -œÇ ([block : -Œ±‚Çñ]) #:transparent)
#|block start |# (struct -œÇ‚Üë -œÇ () #:transparent)
#|block return|# (struct -œÇ‚Üì -œÇ ([cache : -$] [pc : -Œì] [ans : -W]) #:transparent)
#|block raise |# (struct -œÇ! -œÇ ([blm : -blm]) #:transparent)



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;; Blocks
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Stack-address / Evaluation "check-point"
(struct -Œ±‚Çñ ([cache : -$]) #:transparent)
(struct -B -Œ±‚Çñ ([ctx : -H] [var : -formals] [exp : -‚ü¶e‚üß] [env : -œÅ] [pc : -Œì]) #:transparent)
(struct -M -Œ±‚Çñ ([ctx : -H] [blm-ctx : -ctx] [ctc : -W¬π] [val : -W¬π] [pc : -Œì]) #:transparent) ; Contract monitoring
(struct -F -Œ±‚Çñ ([ctx : -H] [l : -l] [loc : ‚Ñì] [ctc : -W¬π] [val : -W¬π] [pc : -Œì]) #:transparent) ; Flat checking
(struct -HV -Œ±‚Çñ ([tag : HV-Tag]) #:transparent) ; Havoc

(-Œ±‚Çñ:ctx . ::= . (-B:ctx -H -formals -‚ü¶e‚üß -œÅ)
                 (-M:ctx -H -ctx -W¬π -W¬π)
                 (-F:ctx -H -l ‚Ñì -W¬π -W¬π)
                 (-HV:ctx HV-Tag))
(struct -Œ±‚Çñ:pth ([cache : -$] [pc : -Œì]) #:transparent)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;; Verification Result
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(-R . ::= . '‚úì '‚úó '?)

;; Take the first definite result
(define-syntax first-R
  (syntax-rules ()
    [(_) '?]
    [(_ R) R]
    [(_ R‚ÇÅ R ...)
     (let ([ans R‚ÇÅ])
       (case ans
         ['? (first-R R ...)]
         [else ans]))]))

(: not-R : -R ‚Üí -R)
;; Negate provability result
(define (not-R R)
  (case R [(‚úì) '‚úó] [(‚úó) '‚úì] [else '?]))

(: boolean->R : Boolean ‚Üí (U '‚úì '‚úó))
(define (boolean->R x) (if x '‚úì '‚úó))


(define-signature env^
  ([‚ä•œÅ : -œÅ]
   [œÅ@ : (-œÅ Symbol ‚Üí ‚ü™Œ±‚ü´)]
   [œÅ+ : (-œÅ Symbol ‚ü™Œ±‚ü´ ‚Üí -œÅ)]
   [-x-dummy : Symbol]))

(define-signature sto^
  ([‚ä•œÉ : -œÉ]
   [œÉ@ : ((U -Œ£ -œÉ) ‚ü™Œ±‚ü´ ‚Üí (‚Ñò -V))]
   [œÉ@¬π : ((U -Œ£ -œÉ) ‚ü™Œ±‚ü´ ‚Üí -V)]
   [œÉ@/list : ((U -Œ£ -œÉ) (Listof ‚ü™Œ±‚ü´) ‚Üí (‚Ñò (Listof -V)))]
   [defined-at? : ((U -Œ£ -œÉ) ‚ü™Œ±‚ü´ ‚Üí Boolean)]
   [œÉ-remove! : (-Œ£ ‚ü™Œ±‚ü´ -V ‚Üí Void)]
   [‚ä•œÉ‚Çñ : -œÉ‚Çñ]
   [œÉ‚Çñ@ : ((U -Œ£ -œÉ‚Çñ) -Œ±‚Çñ ‚Üí (‚Ñò -Œ∫))]
   [‚ü™Œ±‚ü´‚Çí‚Çö : ‚ü™Œ±‚ü´]
   [‚ä§$ : -$]
   [‚ä§$* : -Œ¥$]
   [$-set : (-$ -loc -?t ‚Üí -$)]
   [$-set* : (-$ (Listof -loc) (Listof -?t) ‚Üí -$)]
   [$-set! : (-Œ£ -$ ‚ü™Œ±‚ü´ -loc -?t ‚Üí -$)]
   [$-del : (-$ -loc ‚Üí -$)]
   [$-del* : (-$ (Sequenceof -loc) ‚Üí -$)]
   [$@! : (-Œ£ -Œì ‚ü™Œ±‚ü´ -$ -loc ‚Ñì ‚Üí (Values (‚Ñò -W¬π) -$))]
   [$-extract : (-$ (Sequenceof -loc) ‚Üí -Œ¥$)]
   [$-restore : (-$ -Œ¥$ ‚Üí -$)]
   [$‚Üì : (-$ (‚Ñò -loc) ‚Üí -$)]
   [$-cleanup : (-$ ‚Üí -$)]
   [$-symbolic-names : (-$ ‚Üí (‚Ñò (U Symbol ‚Ñì)))]
   [‚ä•ùíú : -ùíú]
   [get-aliases : (-Œ£ ‚ü™Œ±‚ü´ ‚Üí (‚Ñò -loc))]
   [hack:Œ±->loc : (‚ü™Œ±‚ü´ ‚Üí (Option -loc))]
   [mutable? : (‚ü™Œ±‚ü´ ‚Üí Boolean)]
   [escaped-field-addresses : (-œÉ ‚Üí (‚Ñò ‚ü™Œ±‚ü´))]
   ))

(define-signature val^
  ([+‚óè : (-h * ‚Üí -‚óè)]
   [+W¬π : ([-prim] [-?t] . ->* . -W¬π)]
   [+W : ([(Listof -prim)] [-?t] . ->* . -W)]
   [W¬π->W : (-W¬π ‚Üí -W)]
   [W->W¬πs : (-W -> (Listof -W¬π))]
   [C-flat? : (-V ‚Üí Boolean)]
   [with-negative-party : (-l -V ‚Üí -V)]
   [with-positive-party : (-l -V ‚Üí -V)]
   [behavioral? : (-œÉ -V ‚Üí Boolean)]
   [guard-arity : (-=>_ ‚Üí Arity)]
   [blm-arity : (‚Ñì -l Arity (Listof -V) ‚Üí -blm)]
   [predicates-of-V : (-V ‚Üí (‚Ñò -h))]
   ))

(define-signature pc^
  ([‚ä§Œì : -Œì]
   [Œì‚Üì : (-Œì (‚Ñò (U Symbol ‚Ñì)) ‚Üí -Œì)]
   [t-contains? : (-t -t ‚Üí Boolean)]
   [t-contains-any? : (-t (‚Ñò -t) ‚Üí Boolean)]
   [bin-o->h : (-special-bin-o ‚Üí Base ‚Üí -h)]
   [flip-bin-o : (-special-bin-o ‚Üí -special-bin-o)]
   [neg-bin-o : (-special-bin-o ‚Üí -special-bin-o)]
   [complement? : (-t -t ‚Üí  Boolean)]
   ;; simp
   [?t@ : ((Option -h) -?t * ‚Üí -?t)]
   [op-‚â°? : (Any ‚Üí Boolean)]
   ;; split
   [-struct/c-split : (-?t -ùíæ ‚Üí (Listof -?t))]
   [-struct-split : (-?t -ùíæ ‚Üí (Listof -?t))]
   [-ar-split : (-?t ‚Üí (Values -?t -?t))]
   [-->-split : (-?t (U Index arity-at-least) ‚Üí (Values (-maybe-var -?t) -?t))]
   [-->i-split : (-?t Index ‚Üí (Values (Listof -?t) -?t))]
   [split-values : (-?t Natural ‚Üí (Listof -?t))]
   ;; constr
   [-?list : ((Listof -?t) ‚Üí -?t)]
   [-?unlist : (-?t Natural ‚Üí (Listof -?t))]
   [-app-split : (-h -?t Natural ‚Üí (Listof -?t))]
   [-?-> : ((-maybe-var -?t) -?t ‚Üí -?t)]
   [-?->i : ((Listof -?t) (Option -Œª) ‚Üí -?t)]
   ;; path-cond
   [predicates-of : (-Œì -?t ‚Üí (‚Ñò -h))]
   [fv‚Çú : (-?t ‚Üí (‚Ñò (U Symbol ‚Ñì)))]
   ))

(define-signature summ^
  ([‚ä•Œû : -Œû]
   [Œ±‚Çñ->ctx+pth : (-Œ±‚Çñ ‚Üí (Values -Œ±‚Çñ:ctx -Œ±‚Çñ:pth))]
   [ctx+pth->Œ±‚Çñ : (-Œ±‚Çñ:ctx -Œ±‚Çñ:pth ‚Üí -Œ±‚Çñ)]))

(define-signature instr^
  ([H‚àÖ : -H]
   [H+ : (-H -edge ‚Üí (Values -H Boolean))]
   [strip-C : (-V ‚Üí -edge.tgt)]
   [‚åäœÅ‚åã : (-œÅ ‚Üí -‚åäœÅ‚åã)]
   ))

(define-signature pretty-print^
  ([show-œÇ : (-œÇ ‚Üí Sexp)]
   [show-œÉ : (-œÉ ‚Üí (Listof Sexp))]
   [show-h : (-h ‚Üí Sexp)]
   [show-t : (-?t ‚Üí Sexp)]
   [show-Œì : (-Œì ‚Üí (Listof Sexp))]
   [show-$ : (-$ ‚Üí (Listof Sexp))]
   [show-Œ¥$ : (-Œ¥$ ‚Üí (Listof Sexp))]
   [show-œÉ‚Çñ : (-œÉ‚Çñ ‚Üí (Listof Sexp))]
   [show-blm-reason : ((U -V -v -h) ‚Üí Sexp)]
   [show-V : (-V ‚Üí Sexp)]
   [show-‚ü™Œ±‚ü´‚Ñì : (-‚ü™Œ±‚ü´‚Ñì ‚Üí Symbol)]
   [show-‚ü™Œ±‚ü´‚Ñìs : ((Listof -‚ü™Œ±‚ü´‚Ñì) ‚Üí Sexp)]
   [show-A : (-A ‚Üí Sexp)]
   [show-W¬π : (-W¬π ‚Üí Sexp)]
   [show-‚ü¶e‚üß : (-‚ü¶e‚üß ‚Üí Sexp)]
   [show-Œ±‚Çñ : (-Œ±‚Çñ ‚Üí Sexp)]
   [show-edge : (-edge ‚Üí Sexp)]
   [show-H : (-H ‚Üí Sexp)]
   [show-‚ü™Œ±‚ü´ : (‚ü™Œ±‚ü´ ‚Üí Sexp)]
   [show-Œ∫ : (-Œ∫ ‚Üí Sexp)]
   [show-œÅ : (-œÅ ‚Üí (Listof Sexp))]
   [show-loc : (-loc ‚Üí Sexp)]
   [remember-e! : (-e -‚ü¶e‚üß ‚Üí -‚ü¶e‚üß)]
   [recall-e : (-‚ü¶e‚üß ‚Üí (Option -e))]
   [verbose? : (Parameterof Boolean)]
   ))
