#lang typed/racket/base

(provide mon@)

(require racket/set
         racket/list
         racket/match
         racket/vector
         (only-in racket/function curry)
         typed/racket/unit
         bnf
         set-extras
         unreachable
         "../utils/patterns.rkt"
         "../ast/signatures.rkt"
         "../runtime/signatures.rkt"
         "../execution/signatures.rkt"
         "../signatures.rkt"
         "signatures.rkt"
         )

(‚ü¶C‚üß . ‚âú . (Œ£ Ctx D ‚Üí R))

(define-unit mon@
  (import static-info^
          cache^ val^ sto^ pretty-print^
          exec^ app^ gc^
          prover^)
  (export mon^)

  (define -FF {set -ff})
  (define x-mon (gensym 'mon_))

  (: mon : Œ£ Ctx D D ‚Üí R)
  (define (mon Œ£ ctx C^ V^)
    (define args:root (D-root V^))
    (fold-ans (Œª ([C : V])
                (define root (‚à™ (V-root C) args:root))
                (define Œ£* (gc root Œ£))
                (ref-$! ($:Key:Mon Œ£* (current-MS) ctx C V^)
                        (Œª () (gc-R root Œ£* ((mon‚ÇÅ C) Œ£* ctx V^)))))
              (unpack C^ Œ£)))

  (: mon* : Œ£ Ctx W W ‚Üí R)
  (define (mon* Œ£‚ÇÄ ctx Cs Vs)
    (match-define (Ctx l+ _ ‚Ñì‚Çí ‚Ñì) ctx)
    (if (= (length Cs) (length Vs))
        (let loop ([ŒîŒ£ : ŒîŒ£ ‚ä•ŒîŒ£] [Œ£ : Œ£ Œ£‚ÇÄ] [rev-As : W '()] [Cs : W Cs] [Vs : W Vs] [i : Natural 0])
          (match* (Cs Vs)
            [((cons C‚ÇÅ Cs*) (cons V‚ÇÅ Vs*))
             (define r‚ÇÅ (mon Œ£ (Ctx-with-origin ctx (‚Ñì-with-id ‚Ñì‚Çí i)) C‚ÇÅ V‚ÇÅ))
             (match (collapse-R Œ£ r‚ÇÅ)
               [(cons (app (curry collapse-W^ Œ£) (app car A‚ÇÅ)) ŒîŒ£‚ÇÅ)
                (loop (‚ß∫ ŒîŒ£ ŒîŒ£‚ÇÅ) (‚ß∫ Œ£ ŒîŒ£‚ÇÅ) (cons A‚ÇÅ rev-As) Cs* Vs* (add1 i))]
               [#f ‚ä•R])]
            [('() '())
             (R-of (reverse rev-As) ŒîŒ£)]))
        (match-let ([(Ctx l+ _ ‚Ñì‚Çí ‚Ñì) ctx])
          (err! (blm l+ ‚Ñì ‚Ñì‚Çí Cs Vs))
          ‚ä•R)))

  (: mon‚ÇÅ : V ‚Üí ‚ü¶C‚üß)
  (define (mon‚ÇÅ C)
    (cond [(Fn/C? C) (mon-Fn/C C)]
          [(St/C? C) (mon-St/C C)]
          [(X/C? C) (mon-X/C (X/C-_0 C))]
          [(And/C? C) (mon-And/C C)]
          [(Or/C? C) (mon-Or/C C)]
          [(Not/C? C) (mon-Not/C C)]
          [(One-Of/C? C) (mon-One-Of/C C)]
          [(Vectof/C? C) (mon-Vectof/C C)]
          [(Vect/C? C) (mon-Vect/C C)]
          [(Hash/C? C) (mon-Hash/C C)]
          [(Set/C? C) (mon-Set/C C)]
          [(Seal/C? C) (mon-Seal/C C)]
          [else (mon-Flat/C C)]))

  (: mon-Fn/C : Fn/C ‚Üí ‚ü¶C‚üß)
  (define ((mon-Fn/C C) Œ£ ctx Vs)
    (match-define (Ctx l+ l- ‚Ñì‚Çí ‚Ñì) ctx)
    (with-split-Œ£ Œ£ 'procedure? (list Vs)
      (Œª (W ŒîŒ£‚ÇÅ)
        (define arity-check (P:arity-includes (guard-arity C)))
        (with-split-Œ£ Œ£ arity-check W
          (match-lambda**
           [((list V*‚ÇÄ) _)
            (define V* (unpack V*‚ÇÄ Œ£))
            (define C:sig
              (let ([sig : (==>i ‚Üí Fn/C-Sig)
                     (match-lambda
                       [(==>i doms rngs _)
                        (cons (var-map Dom-name doms) (and rngs (map Dom-name rngs)))])])
                (match C
                  [(? ==>i?) (sig C)]
                  [(‚àÄ/C xs _ _) (cons (-var xs #f) #f)]
                  [(Case-=> Cs) (map sig Cs)])))
            (define-values (Œ±·µ• ŒîŒ£)
              (match V*
                ;; Reduce allocation for common case
                [{singleton-set (? -‚óè? V)} (values (Œ≥:imm V) ‚ä•ŒîŒ£)]
                [_ (define Œ±·µ• (Œ±:dyn (Œ≤:fn ctx C:sig) H‚ÇÄ))
                   (values Œ±·µ• (alloc Œ±·µ• V*))]))
            (R-of {set (Guarded (cons l+ l-) C Œ±·µ•)} ŒîŒ£)])
          (Œª (W _) (err! (blm l+ ‚Ñì‚Çí ‚Ñì (list {set arity-check}) W))
             ‚ä•R)))
      (Œª (W _) (err! (blm l+ ‚Ñì‚Çí ‚Ñì (list {set 'procedure?}) W))
         ‚ä•R)))

  (: mon-St/C : St/C ‚Üí ‚ü¶C‚üß)
  (define ((mon-St/C C) Œ£‚ÇÄ ctx Vs)
    (match-define (Ctx l+ l- ‚Ñì‚Çí ‚Ñì) ctx)
    (define-values (Œ±‚Çï ‚Ñì‚Çï ùíæ) (St/C-fields C))
    (define S (Œ£@/blob Œ±‚Çï Œ£‚ÇÄ))
    (define n (vector-length S))

    (: mon-St/C-fields : Œ£ D ‚Üí R)
    (define (mon-St/C-fields Œ£ V)
      (let go ([i : Index 0] [Vs-rev : W '()] [ŒîŒ£ : ŒîŒ£ ‚ä•ŒîŒ£])
        (cond
          [(>= i n) (R-of (reverse Vs-rev) ŒîŒ£)]
          [else
           (define Œ£‚ß∫ŒîŒ£ (‚ß∫ Œ£ ŒîŒ£))
           (with-collapsing/R Œ£‚ß∫ŒîŒ£ [(ŒîŒ£‚ÇÄ Ws) (app Œ£‚ß∫ŒîŒ£ ‚Ñì {set (-st-ac ùíæ i)} (list V))]
             (define ctx* (Ctx-with-origin ctx (‚Ñì-with-id ‚Ñì‚Çï i)))
             (define C·µ¢ (vector-ref S i))
             (define Œ£* (‚ß∫ Œ£‚ß∫ŒîŒ£ ŒîŒ£‚ÇÄ))
             (with-collapsing/R Œ£* [(ŒîŒ£‚ÇÅ Ws*) (mon Œ£* ctx* C·µ¢ (unpack (car (collapse-W^ Œ£* Ws)) Œ£*))]
               (go (assert (+ 1 i) index?)
                   (cons (car (collapse-W^ (‚ß∫ Œ£* ŒîŒ£‚ÇÅ) Ws*)) Vs-rev)
                   (‚ß∫ ŒîŒ£ ŒîŒ£‚ÇÄ ŒîŒ£‚ÇÅ))))])))

    (with-split-Œ£ Œ£‚ÇÄ (-st-p ùíæ) (list Vs)
      (Œª (W* ŒîŒ£)
        (with-collapsing/R Œ£‚ÇÄ [(ŒîŒ£* Ws) (mon-St/C-fields (‚ß∫ Œ£‚ÇÄ ŒîŒ£) (car W*))]
          (define-values (V‚Çê ŒîŒ£‚Çê)
            (let* ([Œ£‚ÇÄ‚ß∫ŒîŒ£* (‚ß∫ Œ£‚ÇÄ ŒîŒ£*)]
                   [W* (unpack-W (collapse-W^ Œ£‚ÇÄ‚ß∫ŒîŒ£* Ws) Œ£‚ÇÄ‚ß∫ŒîŒ£*)])
              (define Œ± (Œ±:dyn (Œ≤:st-elems ctx ùíæ) H‚ÇÄ))
              (values (St Œ± ‚àÖ) (‚ß∫ ŒîŒ£ ŒîŒ£* (alloc Œ± (list->vector W*))))))
          (if (struct-all-immutable? ùíæ)
              (R-of {set V‚Çê} ŒîŒ£‚Çê)
              (let ([Œ± (Œ±:dyn (Œ≤:st ùíæ ctx) H‚ÇÄ)])
                (R-of {set (Guarded (cons l+ l-) C Œ±)} (‚ß∫ ŒîŒ£‚Çê (alloc Œ± {set V‚Çê})))))))
      (Œª (W* _) (err! (blm l+ ‚Ñì ‚Ñì‚Çí (list {set C}) W*))
         ‚ä•R)))

  (: ?singleton-opaques : W ‚Üí (Option (Listof (‚Ñò P))))
  (define (?singleton-opaques W‚ÇÄ)
    (let go ([W : W W‚ÇÄ])
      (match W
        ['() '()]
        [(cons {singleton-set (-‚óè Ps)} W*)
         (match (go W*)
           [(? values l) (cons Ps l)]
           [_ #f])]
        [_ #f])))

  (: mon-X/C : Œ± ‚Üí ‚ü¶C‚üß)
  ;; Need explicit contract reference to explicitly hint execution of loop
  (define ((mon-X/C Œ±) Œ£ ctx V^) (mon Œ£ ctx (Œ£@ Œ± Œ£) (unpack V^ Œ£)))

  (: mon-And/C : And/C ‚Üí ‚ü¶C‚üß)
  (define ((mon-And/C C) Œ£ ctx V^)
    (match-define (And/C Œ±‚ÇÅ Œ±‚ÇÇ ‚Ñì) C)
    (with-collapsing/R Œ£ [(ŒîŒ£‚ÇÅ Ws‚ÇÅ) (mon Œ£ (Ctx-with-origin ctx (‚Ñì-with-id ‚Ñì 0)) (Œ£@ Œ±‚ÇÅ Œ£) V^)]
      (define Œ£‚ÇÅ (‚ß∫ Œ£ ŒîŒ£‚ÇÅ))
      (match-define (list V^*) (collapse-W^ Œ£‚ÇÅ Ws‚ÇÅ))
      (ŒîŒ£‚ß∫R ŒîŒ£‚ÇÅ (mon Œ£‚ÇÅ (Ctx-with-origin ctx (‚Ñì-with-id ‚Ñì 1)) (Œ£@ Œ±‚ÇÇ Œ£) V^*))))

  (: mon-Or/C : Or/C ‚Üí ‚ü¶C‚üß)
  (define ((mon-Or/C C) Œ£ ctx V)
    (match-define (Or/C Œ±‚ÇÅ Œ±‚ÇÇ ‚Ñì) C)

    (: chk : V^ V^ ‚Üí R)
    (define (chk C-fo C-ho)
      (with-collapsing/R Œ£
        [(ŒîŒ£ Ws)
         (with-each-path ([(ŒîŒ£‚ÇÅ W‚ÇÅ) (fc Œ£ (Ctx-origin ctx) C-fo V)])
           (match W‚ÇÅ
             [(list _) (R-of W‚ÇÅ ŒîŒ£‚ÇÅ)]
             [(list V* _)
              (ŒîŒ£‚ß∫R ŒîŒ£‚ÇÅ
                (mon (‚ß∫ Œ£ ŒîŒ£‚ÇÅ) (Ctx-with-origin ctx (‚Ñì-with-id ‚Ñì 1)) C-ho V*))]))]
        (R-of (collapse-W^ (‚ß∫ Œ£ ŒîŒ£) Ws) ŒîŒ£)))
    (define C‚ÇÅ (Œ£@ Œ±‚ÇÅ Œ£))
    (define C‚ÇÇ (Œ£@ Œ±‚ÇÇ Œ£))
    (cond [(C^-flat? C‚ÇÅ Œ£) (chk C‚ÇÅ C‚ÇÇ)]
          [(C^-flat? C‚ÇÇ Œ£) (chk C‚ÇÇ C‚ÇÅ)]
          [else (error 'or/c "No more than 1 higher-order disjunct for now")]))

  (: mon-Not/C : Not/C ‚Üí ‚ü¶C‚üß)
  (define ((mon-Not/C C) Œ£ ctx V)
    (match-define (Not/C Œ± _) C)
    (match-define (Ctx l+ _ ‚Ñì‚Çí ‚Ñì) ctx)
    (with-each-path ([(ŒîŒ£ W) (fc Œ£ ‚Ñì‚Çí (Œ£@ Œ± Œ£) V)])
      (match W
        [(list Vs* _) (R-of Vs* ŒîŒ£)]
        [(list _) (err! (blm l+ ‚Ñì ‚Ñì‚Çí (list {set C}) (list V)))
                  ‚ä•R])))

  (: mon-One-Of/C : One-Of/C ‚Üí ‚ü¶C‚üß)
  (define ((mon-One-Of/C C) Œ£ ctx Vs)
    (match-define (Ctx l+ _ ‚Ñì‚Çí ‚Ñì) ctx)
    (with-split-Œ£ Œ£ C (list Vs)
      R-of
      (Œª (W _) (err! (blm l+ ‚Ñì ‚Ñì‚Çí (list {set C}) W))
         ‚ä•R)))

  (: mon-Vectof/C : Vectof/C ‚Üí ‚ü¶C‚üß)
  (define ((mon-Vectof/C C) Œ£ ctx Vs)
    (match-define (Ctx l+ l- ‚Ñì‚Çí ‚Ñì) ctx)
    (with-split-Œ£ Œ£ 'vector? (list Vs)
      (Œª (W* ŒîŒ£‚ÇÄ)
        (define V* (car W*))
        (match-define (Vectof/C Œ±‚Çï ‚Ñì‚Çï) C)
        (define N (-‚óè {set 'exact-nonnegative-integer?}))
        (define Œ£‚ÇÄ (‚ß∫ Œ£ ŒîŒ£‚ÇÄ))
        (with-collapsing/R Œ£‚ÇÄ [(ŒîŒ£‚ÇÅ W‚Çës) (app Œ£‚ÇÄ ‚Ñì‚Çí {set 'vector-ref} (list V* {set N}))]
          (define Œ£‚ÇÅ (‚ß∫ Œ£‚ÇÄ ŒîŒ£‚ÇÅ))
          (with-collapsing/R Œ£‚ÇÅ [(ŒîŒ£‚ÇÇ _) (mon Œ£‚ÇÅ (Ctx-with-origin ctx (‚Ñì-with-id ‚Ñì‚Çï 'mon-VectOf/C)) (Œ£@ Œ±‚Çï Œ£) (car (collapse-W^ Œ£‚ÇÅ W‚Çës)))]
            (define-values (Œ±·µ• ŒîŒ£*)
              (match V*
                [{singleton-set (? -‚óè? V)} (values (Œ≥:imm V) ‚ä•ŒîŒ£)]
                [_ (define Œ±·µ• (Œ±:dyn (Œ≤:unvct ctx) H‚ÇÄ))
                   (values Œ±·µ• (alloc Œ±·µ• V*))]))
            (R-of {set (Guarded (cons l+ l-) C Œ±·µ•)} (‚ß∫ ŒîŒ£‚ÇÄ ŒîŒ£‚ÇÅ ŒîŒ£‚ÇÇ ŒîŒ£*)))))
      (Œª (W* _) (err! (blm l+ ‚Ñì‚Çí ‚Ñì (list {set C}) W*))
         ‚ä•R)))

  (: mon-Vect/C : Vect/C ‚Üí ‚ü¶C‚üß)
  (define ((mon-Vect/C C) Œ£‚ÇÄ ctx Vs)
    (match-define (Ctx l+ l- ‚Ñì‚Çí ‚Ñì) ctx)
    (define-values (Œ±‚Çï ‚Ñì‚Çï n) (Vect/C-fields C))

    (: mon-fields : Œ£ D ‚Üí R)
    (define (mon-fields Œ£‚ÇÄ Vs)
      (define Cs (Œ£@/blob Œ±‚Çï Œ£‚ÇÄ))
      (define (ref [Œ£ : Œ£] [i : Natural])
        (app Œ£ ‚Ñì‚Çí {set 'vector-ref} (list Vs {set (-b i)})))
      (let go ([i : Natural 0] [Œ£ : Œ£ Œ£‚ÇÄ] [ŒîŒ£ : ŒîŒ£ ‚ä•ŒîŒ£])
        (if (>= i n)
            (R-of {set -void} ŒîŒ£)
            (with-collapsing/R Œ£ [(ŒîŒ£‚ÇÄ Ws) (ref Œ£ i)]
              (define ctx* (Ctx-with-origin ctx (‚Ñì-with-id ‚Ñì‚Çï i)))
              (define Œ£‚ÇÅ (‚ß∫ Œ£ ŒîŒ£‚ÇÄ))
              (define C·µ¢ (vector-ref Cs i))
              (with-collapsing/R Œ£‚ÇÅ [(ŒîŒ£‚ÇÅ Ws*) (mon Œ£‚ÇÅ ctx* C·µ¢ (car (collapse-W^ Œ£‚ÇÅ Ws)))]
                (go (+ 1 i) (‚ß∫ Œ£‚ÇÅ ŒîŒ£‚ÇÅ) (‚ß∫ ŒîŒ£ ŒîŒ£‚ÇÄ ŒîŒ£‚ÇÅ)))))))

    (with-split-Œ£ Œ£‚ÇÄ 'vector? (list Vs)
      (Œª (W* ŒîŒ£‚ÇÅ)
        (with-split-Œ£ Œ£‚ÇÄ (P:vec-len n) W*
          (Œª (W* ŒîŒ£‚ÇÇ)
            (define V* (car W*))
            (define Œ£‚ÇÇ (‚ß∫ Œ£‚ÇÄ ŒîŒ£‚ÇÅ ŒîŒ£‚ÇÇ))
            (with-collapsing/R Œ£‚ÇÇ [(ŒîŒ£‚ÇÉ _) (mon-fields Œ£‚ÇÇ V*)]
              (define-values (Œ±·µ• ŒîŒ£*)
                (match V*
                  [{singleton-set (? -‚óè? V)} (values (Œ≥:imm V) ‚ä•ŒîŒ£)]
                  [_ (define Œ±·µ• (Œ±:dyn (Œ≤:unvct ctx) H‚ÇÄ))
                     (values Œ±·µ• (alloc Œ±·µ• V*))]))
              (R-of {set (Guarded (cons l+ l-) C Œ±·µ•)} (‚ß∫ ŒîŒ£‚ÇÅ ŒîŒ£‚ÇÇ ŒîŒ£‚ÇÉ ŒîŒ£*))))
          (Œª (W* _) (err! (blm l+ ‚Ñì ‚Ñì‚Çí (list {set C}) W*))
             ‚ä•R)))
      (Œª (W* _) (err! (blm l+ ‚Ñì ‚Ñì‚Çí (list {set C}) W*))
         ‚ä•R)))

  (: mon-Hash/C : Hash/C ‚Üí ‚ü¶C‚üß)
  (define ((mon-Hash/C C) Œ£‚ÇÄ ctx Vs)
    (match-define (Ctx l+ l- ‚Ñì‚Çí ‚Ñì) ctx)
    (match-define (Hash/C Œ±‚Çñ Œ±·µ• ‚Ñì‚Çï) C)

    (: chk-content : Œ£ V^ ‚Üí R)
    (define (chk-content Œ£ Vs)
      (define dummy-‚Ñì (‚Ñì-with-src +‚Ñì‚ÇÄ 'mon-hash/c))
      (define (chk-with [ac : Symbol] [Œ±‚Çö : Œ±])
        (define r
          (with-collapsing/R Œ£ [(ŒîŒ£ Ws) (app Œ£ dummy-‚Ñì {set ac} (list Vs))]
            (define Œ£* (‚ß∫ Œ£ ŒîŒ£))
            (ŒîŒ£‚ß∫R ŒîŒ£ (mon Œ£* (Ctx-with-origin ctx (‚Ñì-with-id ‚Ñì‚Çï ac)) (Œ£@ Œ±‚Çö Œ£‚ÇÄ) (car (collapse-W^ Œ£* Ws))))))
        (or (collapse-R/ŒîŒ£ Œ£ r) ‚ä•ŒîŒ£))
      (define ŒîŒ£‚ÇÅ (chk-with 'scv:hash-key Œ±‚Çñ))
      (define ŒîŒ£‚ÇÇ (chk-with 'scv:hash-val Œ±·µ•))
      (R-of {set -void} (ŒîŒ£‚äî Œ£ ŒîŒ£‚ÇÅ ŒîŒ£‚ÇÇ)))

    (with-split-Œ£ Œ£‚ÇÄ 'hash? (list Vs)
      (Œª (W* ŒîŒ£‚ÇÄ)
        (define V·µ§ (unpack (car W*) Œ£‚ÇÄ))
        (with-collapsing/R Œ£‚ÇÄ [(ŒîŒ£‚ÇÅ _) (chk-content (‚ß∫ Œ£‚ÇÄ ŒîŒ£‚ÇÄ) V·µ§)]
          (define Œ±·µ§ (Œ±:dyn (Œ≤:unhsh ctx ‚Ñì‚Çï) H‚ÇÄ))
          (R-of {set (Guarded (cons l+ l-) C Œ±·µ§)} (‚ß∫ ŒîŒ£‚ÇÄ ŒîŒ£‚ÇÅ (alloc Œ±·µ§ V·µ§)))))
      (Œª (W* _) (err! (blm l+ ‚Ñì ‚Ñì‚Çí (list {set C}) W*))
         ‚ä•R)))

  (: mon-Set/C : Set/C ‚Üí ‚ü¶C‚üß)
  (define ((mon-Set/C C) Œ£‚ÇÄ ctx Vs)
    (match-define (Ctx l+ l- ‚Ñì‚Çí ‚Ñì) ctx)
    (match-define (Set/C Œ±‚Çë ‚Ñì‚Çõ) C)

    (: chk-content : Œ£ V^ ‚Üí R)
    (define (chk-content Œ£ Vs)
      (define dummy-‚Ñì (‚Ñì-with-src +‚Ñì‚ÇÄ 'mon-set/c))
      (with-collapsing/R Œ£ [(ŒîŒ£ Ws) (app Œ£ dummy-‚Ñì {set 'set-first} (list Vs))]
        (define Œ£* (‚ß∫ Œ£ ŒîŒ£))
        (ŒîŒ£‚ß∫R ŒîŒ£ (mon Œ£* (Ctx-with-origin ctx (‚Ñì-with-id ‚Ñì‚Çõ 'set-first)) (Œ£@ Œ±‚Çë Œ£) (car (collapse-W^ Œ£* Ws))))))

    (with-split-Œ£ Œ£‚ÇÄ 'set? (list Vs)
      (Œª (W* ŒîŒ£‚ÇÄ)
        (define V·µ§ (unpack (car W*) Œ£‚ÇÄ))
        (define Œ£‚ÇÅ (‚ß∫ Œ£‚ÇÄ ŒîŒ£‚ÇÄ))
        (with-collapsing/R Œ£‚ÇÅ [(ŒîŒ£‚ÇÅ _) (chk-content Œ£‚ÇÅ V·µ§)]
          (define Œ±·µ§ (Œ±:dyn (Œ≤:unset ctx ‚Ñì‚Çõ) H‚ÇÄ))
          (R-of {set (Guarded (cons l+ l-) C Œ±·µ§)} (‚ß∫ ŒîŒ£‚ÇÄ ŒîŒ£‚ÇÅ (alloc Œ±·µ§ V·µ§)))))
      (Œª (W* _) (err! (blm l+ ‚Ñì ‚Ñì‚Çí (list {set C}) W*))
         ‚ä•R)))

  (: mon-Seal/C : Seal/C ‚Üí ‚ü¶C‚üß)
  (define ((mon-Seal/C C) Œ£ ctx V^*)
    (match-define (Seal/C Œ± l) C)
    (match-define (Ctx l+ l- ‚Ñì‚Çí ‚Ñì) ctx)
    (define V^ (unpack V^* Œ£))
    (cond
      ;; Seal position
      [(equal? l+ l) (R-of {set (Sealed Œ±)} (alloc Œ± V^))]
      ;; Unseal position
      [(equal? l- l)
       (define unsealed (Œ£@ Œ± Œ£))
       (define ers (blm l+ ‚Ñì ‚Ñì‚Çí (list {set C}) (list (set-remove V^ (Sealed Œ±)))))
       ((inst fold-ans V)
        (match-lambda
          [(Sealed (== Œ±)) (R-of unsealed)]
          [(? -‚óè?) (R-of unsealed ‚ä•ŒîŒ£)]
          [_ (err! ers) ‚ä•R])
        V^)]
      [else !!!]))

  (: mon-Flat/C : V ‚Üí ‚ü¶C‚üß)
  (define ((mon-Flat/C C) Œ£ ctx Vs)
    (match-define (Ctx l+ _ ‚Ñì‚Çí ‚Ñì) ctx)
    (define (blame) (blm l+ ‚Ñì ‚Ñì‚Çí (list {set C}) (list Vs)))
    (case (sat Œ£ C Vs)
      [(‚úì) (R-of Vs)]
      [(‚úó) (err! (blame)) ‚ä•R]
      [else
       (with-each-path ([(ŒîŒ£ W) (fc Œ£ ‚Ñì‚Çí {set C} Vs)])
         (match W
           [(list _) (R-of W ŒîŒ£)]
           [(list Vs* _) (err! (blame)) ‚ä•R]))]))

  ;; Can't get away with not having specialized flat-check procedure.
  ;; There's no straightforward way to fully refine a value by contract `c`
  ;; after applying `c` as a procedure (tricky when `c` is recursive and effectful)
  ;; Convention: `fc` returns:
  ;; - `[refine(v, c)   ]` if `v`          satisfies `c`
  ;; - `[refine(v,¬¨c),#f]` if `v` does not satisfies `c`,
  (: fc : Œ£ ‚Ñì D D ‚Üí R)
  (define (fc Œ£‚ÇÄ ‚Ñì Cs Vs)
    (define Vs:root (D-root Vs))
    ((inst fold-ans V)
     (Œª (C)
       (define root (‚à™ (V-root C) Vs:root))
       (define Œ£‚ÇÄ* (gc root Œ£‚ÇÄ))
       (ref-$! ($:Key:Fc Œ£‚ÇÄ* (current-MS) ‚Ñì C Vs)
               (Œª () (gc-R root Œ£‚ÇÄ* (fc‚ÇÅ Œ£‚ÇÄ* ‚Ñì C Vs)))))
     (unpack Cs Œ£‚ÇÄ)))

  (: fc‚ÇÅ : Œ£ ‚Ñì V D ‚Üí R)
  (define (fc‚ÇÅ Œ£‚ÇÄ ‚Ñì C Vs)
    (match C
      [(And/C Œ±‚ÇÅ Œ±‚ÇÇ _)
       (with-collapsing/R Œ£‚ÇÄ [(ŒîŒ£‚ÇÅ Ws‚ÇÅ) (fc Œ£‚ÇÄ ‚Ñì (Œ£@ Œ±‚ÇÅ Œ£‚ÇÄ) Vs)]
         (for/fold ([r : R ‚ä•R]) ([W‚ÇÅ (in-set Ws‚ÇÅ)])
           (match W‚ÇÅ
             [(list Vs*)
              (R‚äî r (ŒîŒ£‚ß∫R ŒîŒ£‚ÇÅ (fc (‚ß∫ Œ£‚ÇÄ ŒîŒ£‚ÇÅ) ‚Ñì (Œ£@ Œ±‚ÇÇ Œ£‚ÇÄ) Vs*)))]
             [(list _ _) (R‚äî r (R-of W‚ÇÅ ŒîŒ£‚ÇÅ))])))]
      [(Or/C Œ±‚ÇÅ Œ±‚ÇÇ _)
       (with-collapsing/R Œ£‚ÇÄ [(ŒîŒ£‚ÇÅ Ws‚ÇÅ) (fc Œ£‚ÇÄ ‚Ñì (Œ£@ Œ±‚ÇÅ Œ£‚ÇÄ) Vs)]
         (for/fold ([r : R ‚ä•R]) ([W‚ÇÅ (in-set Ws‚ÇÅ)])
           (match W‚ÇÅ
             [(list _) (R‚äî r (R-of W‚ÇÅ ŒîŒ£‚ÇÅ))]
             [(list Vs* _)
              (define r‚ÇÇ (fc (‚ß∫ Œ£‚ÇÄ ŒîŒ£‚ÇÅ) ‚Ñì (Œ£@ Œ±‚ÇÇ Œ£‚ÇÄ) Vs*))
              (R‚äî r (ŒîŒ£‚ß∫R ŒîŒ£‚ÇÅ r‚ÇÇ))])))]
      [(Not/C Œ± _)
       (with-collapsing/R Œ£‚ÇÄ [(ŒîŒ£‚ÇÅ Ws‚ÇÅ) (fc Œ£‚ÇÄ ‚Ñì (Œ£@ Œ± Œ£‚ÇÄ) Vs)]
         (for/fold ([r : R ‚ä•R]) ([W‚ÇÅ (in-set Ws‚ÇÅ)])
           (R‚äî r (R-of (match W‚ÇÅ
                         [(list Vs*) (list Vs* -FF)]
                         [(list Vs* _) (list Vs*)])
                       ŒîŒ£‚ÇÅ))))]
      [(One-Of/C bs)
       (with-split-Œ£ Œ£‚ÇÄ (One-Of/C bs) (list Vs)
         R-of
         (Œª (W ŒîŒ£) (R-of (list (car W) -FF) ŒîŒ£)))]
      [(? St/C? C)
       (define-values (Œ±‚Çï _ ùíæ) (St/C-fields C))
       (define S (Œ£@/blob Œ±‚Çï Œ£‚ÇÄ))
       (define n (vector-length S))
       (with-split-Œ£ Œ£‚ÇÄ (-st-p ùíæ) (list Vs)
         (Œª (W* ŒîŒ£*)
           (define n (count-struct-fields ùíæ))
           (let go ([Œ£ : Œ£ Œ£‚ÇÄ] [i : Index 0] [ŒîŒ£ : ŒîŒ£ ŒîŒ£*] [rev-W : W '()])
             (cond
               [(>= i n)
                (define Œ± (Œ±:dyn (Œ≤:st-elems ‚Ñì ùíæ) H‚ÇÄ))
                (R-of {set (St Œ± ‚àÖ)} (‚ß∫ ŒîŒ£ (alloc Œ± (list->vector (unpack-W (reverse rev-W) Œ£)))))]
               [else
                (define C·µ¢ (vector-ref S i))
                (with-collapsing/R Œ£ [(ŒîŒ£:a Ws:a) (app Œ£ ‚Ñì {set (-st-ac ùíæ i)} W*)]
                  (define Œ£* (‚ß∫ Œ£ ŒîŒ£:a))
                  (with-each-path ([(ŒîŒ£·µ¢ W·µ¢) (fc Œ£* ‚Ñì C·µ¢ (car (collapse-W^ Œ£* Ws:a)))])
                    (match W·µ¢
                      [(list V·µ¢)
                       (go (‚ß∫ Œ£ ŒîŒ£:a ŒîŒ£·µ¢)
                           (assert (+ 1 i) index?)
                           (‚ß∫ ŒîŒ£ ŒîŒ£:a ŒîŒ£·µ¢) (cons V·µ¢ rev-W))]
                      [(list V·µ¢ _)
                       (define fields ((inst vector-append V^)
                                       (list->vector (unpack-W (reverse rev-W) Œ£))
                                       (make-vector (- n i 1) {set (-‚óè ‚àÖ)})))
                       (define Œ± (Œ±:dyn (Œ≤:st-elems ‚Ñì ùíæ) H‚ÇÄ))
                       (R-of (list {set (St Œ± ‚àÖ)} -FF) (‚ß∫ ŒîŒ£:a ŒîŒ£·µ¢ (alloc Œ± fields)))])))])))
         (Œª (W ŒîŒ£) (R-of (list (car W) -FF) ŒîŒ£)))]
      [(X/C Œ±) (fc Œ£‚ÇÄ ‚Ñì (Œ£@ Œ± Œ£‚ÇÄ) (unpack Vs Œ£‚ÇÄ))]
      [(and b (-b ub))
       (with-split-Œ£ Œ£‚ÇÄ 'equal? (list {set b} Vs)
         (Œª (_ ŒîŒ£) (R-of {set b} ŒîŒ£))
         (Œª (W ŒîŒ£)
           (define-values (V* ŒîŒ£*) (refine (cadr W) (P:¬¨ (P:‚â° ub)) Œ£‚ÇÄ))
           (R-of (list V* -FF) (‚ß∫ ŒîŒ£ ŒîŒ£*))))]
      [_
       (define ŒîŒ£‚Çì (alloc-lex Œ£‚ÇÄ x-mon Vs))
       (define Œ£‚ÇÅ (‚ß∫ Œ£‚ÇÄ ŒîŒ£‚Çì))
       ;; FIXME instead of manually `resolve` like this, make the whole thing
       ;; more analogous to applying lamdbas
       (with-each-path ([(ŒîŒ£ W) (app Œ£‚ÇÅ ‚Ñì {set C} (list (resolve x-mon Œ£‚ÇÅ)))])
         (define Œ£‚ÇÇ (‚ß∫ Œ£‚ÇÅ ŒîŒ£))
         (define Vs* (Œ£@ (Œ≥:lex x-mon) Œ£‚ÇÇ))
         (with-split-Œ£ Œ£‚ÇÇ 'values W
           (Œª _ (R-of Vs* ŒîŒ£))
           (Œª _ (R-of (list Vs* -FF) ŒîŒ£))))]))
  )
